!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["Gaussian Splats 3D"]=e["Gaussian Splats 3D"]||{},e.THREE)}(this,(function(e,t){"use strict";function s(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(s){if("default"!==s){var n=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(t,s,n.get?n:{enumerable:!0,get:function(){return e[s]}})}})),t.default=e,Object.freeze(t)}var n=s(t);class r{static idGen=0;constructor(e,t){let s,n;this.promise=new Promise(((e,t)=>{s=e,n=t}));const i=s.bind(this),o=n.bind(this);e(((...e)=>{i(...e)}).bind(this),(e=>{o(e)}).bind(this)),this.abortHandler=t,this.id=r.idGen++}then(e){return new r(((t,s)=>{this.promise=this.promise.then(((...s)=>{const n=e(...s);n instanceof Promise||n instanceof r?n.then(((...e)=>{t(...e)})):t(n)})).catch((e=>{s(e)}))}),this.abortHandler)}catch(e){return new r((t=>{this.promise=this.promise.then(((...e)=>{t(...e)})).catch(e)}),this.abortHandler)}abort(){this.abortHandler&&this.abortHandler()}}class i extends Error{constructor(e){super(e)}}!function(){const e=new Float32Array(1),t=new Int32Array(e.buffer)}();const o=function(){const e=new Float32Array(1),t=new Int32Array(e.buffer);return function(s){return e[0]=s,t[0]}}(),a=function(e,t,s=!0){const n=new AbortController,o=n.signal;let a=!1,l=null;return new r(((n,r)=>{l=r,fetch(e,{signal:o}).then((async e=>{const i=e.body.getReader();let o=0,l=e.headers.get("Content-Length"),c=l?parseInt(l):void 0;const h=[];for(;!a;)try{const{value:e,done:r}=await i.read();if(r){if(t&&t(100,"100%",e,c),s){const e=new Blob(h).arrayBuffer();n(e)}else n();break}let a,l;if(o+=e.length,void 0!==c&&(a=o/c*100,l=`${a.toFixed(2)}%`),s&&h.push(e),t){t(a,l,e,c)&&(s=!1)}}catch(e){r(e);break}}))}),(e=>{n.abort(e),l(new i("Fetch aborted.")),a=!0}))},l=function(e,t,s){return Math.max(Math.min(e,s),t)},c=function(){return performance.now()/1e3},h=e=>{if(e.geometry&&(e.geometry.dispose(),e.geometry=null),e.material&&(e.material.dispose(),e.material=null),e.children)for(let t of e.children)h(t)},d=(e,t)=>new Promise((s=>{window.setTimeout((()=>{s(e())}),t?1:50)})),p=(e=0)=>{switch(e){case 1:return 9;case 2:return 24}return 0},u=()=>{let e,t;return{promise:new Promise(((s,n)=>{e=s,t=n})),resolve:e,reject:t}},A=e=>{let t,s;e||(e=()=>{});return{promise:new r(((e,n)=>{t=e,s=n}),e),resolve:t,reject:s}};class m{constructor(e,t,s){this.major=e,this.minor=t,this.patch=s}toString(){return`${this.major}_${this.minor}_${this.patch}`}}function g(){const e=navigator.userAgent;return e.indexOf("iPhone")>0||e.indexOf("iPad")>0}function f(){if(g()){const e=navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);return new m(parseInt(e[1]||0,10),parseInt(e[2]||0,10),parseInt(e[3]||0,10))}return null}class C{static OFFSET={X:0,Y:1,Z:2,SCALE0:3,SCALE1:4,SCALE2:5,ROTATION0:6,ROTATION1:7,ROTATION2:8,ROTATION3:9,FDC0:10,FDC1:11,FDC2:12,OPACITY:13,FRC0:14,FRC1:15,FRC2:16,FRC3:17,FRC4:18,FRC5:19,FRC6:20,FRC7:21,FRC8:22,FRC9:23,FRC10:24,FRC11:25,FRC12:26,FRC13:27,FRC14:28,FRC15:29,FRC16:30,FRC17:31,FRC18:32,FRC19:33,FRC20:34,FRC21:35,FRC22:36,FRC23:37};constructor(e=0){this.sphericalHarmonicsDegree=e,this.sphericalHarmonicsCount=p(this.sphericalHarmonicsDegree),this.componentCount=this.sphericalHarmonicsCount+14,this.defaultSphericalHarmonics=new Array(this.sphericalHarmonicsCount).fill(0),this.splats=[],this.splatCount=0}static createSplat(e=0){const t=[0,0,0,1,1,1,1,0,0,0,0,0,0,0];let s=p(e);for(let e=0;e<s;e++)t.push(0);return t}addSplat(e){this.splats.push(e),this.splatCount++}getSplat(e){return this.splats[e]}addDefaultSplat(){const e=C.createSplat(this.sphericalHarmonicsDegree);return this.addSplat(e),e}addSplatFromComonents(e,t,s,n,r,i,o,a,l,c,h,d,p,u,...A){const m=[e,t,s,n,r,i,o,a,l,c,h,d,p,u,...this.defaultSphericalHarmonics];for(let e=0;e<A.length&&e<this.sphericalHarmonicsCount;e++)m[e]=A[e];return this.addSplat(m),m}addSplatFromArray(e,t){const s=e.splats[t],n=C.createSplat(this.sphericalHarmonicsDegree);for(let e=0;e<this.componentCount&&e<s.length;e++)n[e]=s[e];this.addSplat(n)}}class S{static DepthMapRange=65536;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4;static MaxScenes=32;static ProgressiveLoadSectionSize=262144;static ProgressiveLoadSectionDelayDuration=15;static SphericalHarmonics8BitCompressionRange=3}const y=S.SphericalHarmonics8BitCompressionRange/2,x=n.DataUtils.toHalfFloat.bind(n.DataUtils),I=e=>(e=l(e,-y,y),l(Math.floor(255*(e*(.5/y)+.5)),0,255)),v=n.DataUtils.fromHalfFloat.bind(n.DataUtils),B=e=>I(v(e)),w=(e,t,s=!1)=>0===t?e:1===t||2===t&&!s?n.DataUtils.fromHalfFloat(e):2===t?e/255*S.SphericalHarmonics8BitCompressionRange-y:void 0,b=(e,t,s,n=!1)=>0===s?e.getFloat32(4*t,!0):1===s||2===s&&!n?e.getUint16(2*t,!0):e.getUint8(t,!0),E=(e,t,s,n,r=0)=>{const i=new Uint8Array(e,t),o=new Uint8Array(s,n);for(let e=0;e<r;e++)o[e]=i[e]};class D{static CurrentMajorVersion=0;static CurrentMinorVersion=1;static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CovarianceComponentCount=6;static SplatScaleOffsetFloat=3;static SplatRotationOffsetFloat=6;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerRotation:16,BytesPerColor:4,ScaleOffsetBytes:12,RotationffsetBytes:24,ColorOffsetBytes:40,SphericalHarmonicsOffsetBytes:44,ScaleRange:1,BytesPerSphericalHarmonicsComponent:4,SphericalHarmonicsOffsetFloat:11,SphericalHarmonicsDegrees:{0:{BytesPerSplat:44},1:{BytesPerSplat:80},2:{BytesPerSplat:140}}},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:2,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:42},2:{BytesPerSplat:72}}},2:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:1,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:33},2:{BytesPerSplat:48}}}};static CovarianceSizeFloats=6;static HeaderSizeBytes=4096;static SectionHeaderSizeBytes=1024;static BucketStorageSizeBytes=12;static BucketStorageSizeFloats=3;static BucketBlockSize=5;static BucketSize=256;constructor(e,t=!0){this.constructFromBuffer(e,t)}getSplatCount(){return this.splatCount}getMaxSplatCount(){return this.maxSplatCount}getMinSphericalHarmonicsDegree(){let e=0;for(let t=0;t<this.sections.length;t++){const s=this.sections[t];(0===t||s.sphericalHarmonicsDegree<e)&&(e=s.sphericalHarmonicsDegree)}return e}getBucketIndex(e,t){let s;const n=e.fullBucketCount*e.bucketSize;if(t<n)s=Math.floor(t/e.bucketSize);else{let r=n;s=e.fullBucketCount;let i=0;for(;r<e.splatCount;){let n=e.partiallyFilledBucketLengths[i];if(t>=r&&t<r+n)break;r+=n,s++,i++}}return s}getSplatCenter(e,t,s){const n=this.globalSplatIndexToSectionMap[e],r=this.sections[n],i=e-r.splatCountOffset,o=r.bytesPerSplat*i,a=new DataView(this.bufferData,r.dataBase+o),l=b(a,0,this.compressionLevel),c=b(a,1,this.compressionLevel),h=b(a,2,this.compressionLevel);if(this.compressionLevel>=1){const e=this.getBucketIndex(r,i)*D.BucketStorageSizeFloats,s=r.compressionScaleFactor,n=r.compressionScaleRange;t.x=(l-n)*s+r.bucketArray[e],t.y=(c-n)*s+r.bucketArray[e+1],t.z=(h-n)*s+r.bucketArray[e+2]}else t.x=l,t.y=c,t.z=h;s&&t.applyMatrix4(s)}getSplatScaleAndRotation=function(){const e=new n.Matrix4,t=new n.Matrix4,s=new n.Matrix4,r=new n.Vector3,i=new n.Vector3,o=new n.Quaternion;return function(n,a,l,c){const h=this.globalSplatIndexToSectionMap[n],d=this.sections[h],p=n-d.splatCountOffset,u=d.bytesPerSplat*p+D.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,A=new DataView(this.bufferData,d.dataBase+u);i.set(w(b(A,0,this.compressionLevel),this.compressionLevel),w(b(A,1,this.compressionLevel),this.compressionLevel),w(b(A,2,this.compressionLevel),this.compressionLevel)),o.set(w(b(A,4,this.compressionLevel),this.compressionLevel),w(b(A,5,this.compressionLevel),this.compressionLevel),w(b(A,6,this.compressionLevel),this.compressionLevel),w(b(A,3,this.compressionLevel),this.compressionLevel)),c?(e.makeScale(i.x,i.y,i.z),t.makeRotationFromQuaternion(o),s.copy(e).multiply(t).multiply(c),s.decompose(r,l,a)):(a.copy(i),l.copy(o))}}();getSplatColor(e,t){const s=this.globalSplatIndexToSectionMap[e],n=this.sections[s],r=e-n.splatCountOffset,i=n.bytesPerSplat*r+D.CompressionLevels[this.compressionLevel].ColorOffsetBytes,o=new Uint8Array(this.bufferData,n.dataBase+i,4);t.set(o[0],o[1],o[2],o[3])}fillSplatCenterArray(e,t,s,r,i){const o=this.splatCount;s=s||0,r=r||o-1,void 0===i&&(i=s);const a=new n.Vector3;for(let n=s;n<=r;n++){const r=this.globalSplatIndexToSectionMap[n],o=this.sections[r],l=n-o.splatCountOffset,c=(n-s+i)*D.CenterComponentCount,h=o.bytesPerSplat*l,d=new DataView(this.bufferData,o.dataBase+h),p=b(d,0,this.compressionLevel),u=b(d,1,this.compressionLevel),A=b(d,2,this.compressionLevel);if(this.compressionLevel>=1){const e=this.getBucketIndex(o,l)*D.BucketStorageSizeFloats,t=o.compressionScaleFactor,s=o.compressionScaleRange;a.x=(p-s)*t+o.bucketArray[e],a.y=(u-s)*t+o.bucketArray[e+1],a.z=(A-s)*t+o.bucketArray[e+2]}else a.x=p,a.y=u,a.z=A;t&&a.applyMatrix4(t),e[c]=a.x,e[c+1]=a.y,e[c+2]=a.z}}static computeCovariance=function(){const e=new n.Matrix4,t=new n.Matrix3,s=new n.Matrix3,r=new n.Matrix3,i=new n.Matrix3,o=new n.Matrix3,a=new n.Matrix3;return function(n,l,c,h,d=0,p){e.makeScale(n.x,n.y,n.z),t.setFromMatrix4(e),e.makeRotationFromQuaternion(l),s.setFromMatrix4(e),r.copy(s).multiply(t),i.copy(r).transpose().premultiply(r),c&&(o.setFromMatrix4(c),a.copy(o).transpose(),i.multiply(a),i.premultiply(o)),p>=1?(h[d]=x(i.elements[0]),h[d+1]=x(i.elements[3]),h[d+2]=x(i.elements[6]),h[d+3]=x(i.elements[4]),h[d+4]=x(i.elements[7]),h[d+5]=x(i.elements[8])):(h[d]=i.elements[0],h[d+1]=i.elements[3],h[d+2]=i.elements[6],h[d+3]=i.elements[4],h[d+4]=i.elements[7],h[d+5]=i.elements[8])}}();fillSplatCovarianceArray(e,t,s,r,i,o){const a=this.splatCount,l=new n.Vector3,c=new n.Quaternion;s=s||0,r=r||a-1,void 0===i&&(i=s);for(let n=s;n<=r;n++){const r=this.globalSplatIndexToSectionMap[n],a=this.sections[r],h=n-a.splatCountOffset,d=(n-s+i)*D.CovarianceComponentCount,p=a.bytesPerSplat*h+D.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,u=new DataView(this.bufferData,a.dataBase+p);l.set(w(b(u,0,this.compressionLevel),this.compressionLevel),w(b(u,1,this.compressionLevel),this.compressionLevel),w(b(u,2,this.compressionLevel),this.compressionLevel)),c.set(w(b(u,4,this.compressionLevel),this.compressionLevel),w(b(u,5,this.compressionLevel),this.compressionLevel),w(b(u,6,this.compressionLevel),this.compressionLevel),w(b(u,3,this.compressionLevel),this.compressionLevel)),D.computeCovariance(l,c,t,e,d,o)}}fillSplatColorArray(e,t,s,n,r){const i=this.splatCount;s=s||0,n=n||i-1,void 0===r&&(r=s);for(let i=s;i<=n;i++){const n=this.globalSplatIndexToSectionMap[i],o=this.sections[n],a=i-o.splatCountOffset,l=(i-s+r)*D.ColorComponentCount,c=o.bytesPerSplat*a+D.CompressionLevels[this.compressionLevel].ColorOffsetBytes,h=new Uint8Array(this.bufferData,o.dataBase+c);let d=h[3];d=d>=t?d:0,e[l]=h[0],e[l+1]=h[1],e[l+2]=h[2],e[l+3]=d}}fillSphericalHarmonicsArray=function(){const e=[];for(let t=0;t<15;t++)e[t]=new n.Vector3;const t=new n.Matrix3,s=[],r=[],i=[],o=[],a=[],l=[],c=[],h=[],d=[],u=[],A=[],m=[],g=[],f=[],C=[],S=[],y=[],E=[],T=e=>e,M=(e,t,s,n)=>{e[0]=t,e[1]=s,e[2]=n},F=(e,t,s,n,r)=>{e[0]=b(t,n,r,!0),e[1]=b(t,n+s,r,!0),e[2]=b(t,n+s+s,r,!0)},R=(e,t)=>{t[0]=e[0],t[1]=e[1],t[2]=e[2]},P=(e,t,s,n)=>{t[s]=n(e[0]),t[s+1]=n(e[1]),t[s+2]=n(e[2])},k=(e,t,s)=>(t[0]=w(e[0],s,!0),t[1]=w(e[1],s,!0),t[2]=w(e[2],s,!0),t);return function(e,n,w,b,H,L,O){const _=this.splatCount;b=b||0,H=H||_-1,void 0===L&&(L=b),w&&n>=1&&(t.setFromMatrix4(w),M(s,t.elements[4],-t.elements[7],t.elements[1]),M(r,-t.elements[5],t.elements[8],-t.elements[2]),M(i,t.elements[3],-t.elements[6],t.elements[0]));for(let t=b;t<=H;t++){const M=this.globalSplatIndexToSectionMap[t],H=this.sections[M];n=Math.min(n,H.sphericalHarmonicsDegree);const _=p(n),U=t-H.splatCountOffset,Q=H.bytesPerSplat*U+D.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,z=new DataView(this.bufferData,H.dataBase+Q),V=(t-b+L)*_;let N=w?0:this.compressionLevel,G=T;N!==O&&(1===N?0===O?G=v:2==O&&(G=B):0===N&&(1===O?G=x:2==O&&(G=I))),n>=1&&(F(d,z,3,0,this.compressionLevel),F(u,z,3,1,this.compressionLevel),F(A,z,3,2,this.compressionLevel),w?(k(d,d,this.compressionLevel),k(u,u,this.compressionLevel),k(A,A,this.compressionLevel),D.rotateSphericalHarmonics3(d,u,A,s,r,i,f,C,S)):(R(d,f),R(u,C),R(A,S)),P(f,e,V,G),P(C,e,V+3,G),P(S,e,V+6,G),n>=2&&(F(d,z,5,9,this.compressionLevel),F(u,z,5,10,this.compressionLevel),F(A,z,5,11,this.compressionLevel),F(m,z,5,12,this.compressionLevel),F(g,z,5,13,this.compressionLevel),w?(k(d,d,this.compressionLevel),k(u,u,this.compressionLevel),k(A,A,this.compressionLevel),k(m,m,this.compressionLevel),k(g,g,this.compressionLevel),D.rotateSphericalHarmonics5(d,u,A,m,g,s,r,i,o,a,l,c,h,f,C,S,y,E)):(R(d,f),R(u,C),R(A,S),R(m,y),R(g,E)),P(f,e,V+9,G),P(C,e,V+12,G),P(S,e,V+15,G),P(y,e,V+18,G),P(E,e,V+21,G)))}}}();static dot3=(e,t,s,n,r)=>{r[0]=r[1]=r[2]=0;const i=n[0],o=n[1],a=n[2];D.addInto3(e[0]*i,e[1]*i,e[2]*i,r),D.addInto3(t[0]*o,t[1]*o,t[2]*o,r),D.addInto3(s[0]*a,s[1]*a,s[2]*a,r)};static addInto3=(e,t,s,n)=>{n[0]=n[0]+e,n[1]=n[1]+t,n[2]=n[2]+s};static dot5=(e,t,s,n,r,i,o)=>{o[0]=o[1]=o[2]=0;const a=i[0],l=i[1],c=i[2],h=i[3],d=i[4];D.addInto3(e[0]*a,e[1]*a,e[2]*a,o),D.addInto3(t[0]*l,t[1]*l,t[2]*l,o),D.addInto3(s[0]*c,s[1]*c,s[2]*c,o),D.addInto3(n[0]*h,n[1]*h,n[2]*h,o),D.addInto3(r[0]*d,r[1]*d,r[2]*d,o)};static rotateSphericalHarmonics3=(e,t,s,n,r,i,o,a,l)=>{D.dot3(e,t,s,n,o),D.dot3(e,t,s,r,a),D.dot3(e,t,s,i,l)};static rotateSphericalHarmonics5=(e,t,s,n,r,i,o,a,l,c,h,d,p,u,A,m,g,f)=>{const C=Math.sqrt(1/4),S=Math.sqrt(3/4),y=Math.sqrt(1/3),x=Math.sqrt(4/3),I=Math.sqrt(1/12);l[0]=C*(a[2]*i[0]+a[0]*i[2]+(i[2]*a[0]+i[0]*a[2])),l[1]=a[1]*i[0]+i[1]*a[0],l[2]=S*(a[1]*i[1]+i[1]*a[1]),l[3]=a[1]*i[2]+i[1]*a[2],l[4]=C*(a[2]*i[2]-a[0]*i[0]+(i[2]*a[2]-i[0]*a[0])),D.dot5(e,t,s,n,r,l,u),c[0]=C*(o[2]*i[0]+o[0]*i[2]+(i[2]*o[0]+i[0]*o[2])),c[1]=o[1]*i[0]+i[1]*o[0],c[2]=S*(o[1]*i[1]+i[1]*o[1]),c[3]=o[1]*i[2]+i[1]*o[2],c[4]=C*(o[2]*i[2]-o[0]*i[0]+(i[2]*o[2]-i[0]*o[0])),D.dot5(e,t,s,n,r,c,A),h[0]=y*(o[2]*o[0]+o[0]*o[2])+-I*(a[2]*a[0]+a[0]*a[2]+(i[2]*i[0]+i[0]*i[2])),h[1]=x*o[1]*o[0]+-y*(a[1]*a[0]+i[1]*i[0]),h[2]=o[1]*o[1]+-C*(a[1]*a[1]+i[1]*i[1]),h[3]=x*o[1]*o[2]+-y*(a[1]*a[2]+i[1]*i[2]),h[4]=y*(o[2]*o[2]-o[0]*o[0])+-I*(a[2]*a[2]-a[0]*a[0]+(i[2]*i[2]-i[0]*i[0])),D.dot5(e,t,s,n,r,h,m),d[0]=C*(o[2]*a[0]+o[0]*a[2]+(a[2]*o[0]+a[0]*o[2])),d[1]=o[1]*a[0]+a[1]*o[0],d[2]=S*(o[1]*a[1]+a[1]*o[1]),d[3]=o[1]*a[2]+a[1]*o[2],d[4]=C*(o[2]*a[2]-o[0]*a[0]+(a[2]*o[2]-a[0]*o[0])),D.dot5(e,t,s,n,r,d,g),p[0]=C*(a[2]*a[0]+a[0]*a[2]-(i[2]*i[0]+i[0]*i[2])),p[1]=a[1]*a[0]-i[1]*i[0],p[2]=S*(a[1]*a[1]-i[1]*i[1]),p[3]=a[1]*a[2]-i[1]*i[2],p[4]=C*(a[2]*a[2]-a[0]*a[0]-(i[2]*i[2]-i[0]*i[0])),D.dot5(e,t,s,n,r,p,f)};static parseHeader(e){const t=new Uint8Array(e,0,D.HeaderSizeBytes),s=new Uint16Array(e,0,D.HeaderSizeBytes/2),r=new Uint32Array(e,0,D.HeaderSizeBytes/4),i=new Float32Array(e,0,D.HeaderSizeBytes/4);return{versionMajor:t[0],versionMinor:t[1],maxSectionCount:r[1],sectionCount:r[2],maxSplatCount:r[3],splatCount:r[4],compressionLevel:s[10],sceneCenter:new n.Vector3(i[6],i[7],i[8])}}static writeHeaderCountsToBuffer(e,t,s){const n=new Uint32Array(s,0,D.HeaderSizeBytes/4);n[2]=e,n[4]=t}static writeHeaderToBuffer(e,t){const s=new Uint8Array(t,0,D.HeaderSizeBytes),n=new Uint16Array(t,0,D.HeaderSizeBytes/2),r=new Uint32Array(t,0,D.HeaderSizeBytes/4),i=new Float32Array(t,0,D.HeaderSizeBytes/4);s[0]=e.versionMajor,s[1]=e.versionMinor,s[2]=0,s[3]=0,r[1]=e.maxSectionCount,r[2]=e.sectionCount,r[3]=e.maxSplatCount,r[4]=e.splatCount,n[10]=e.compressionLevel,i[6]=e.sceneCenter.x,i[7]=e.sceneCenter.y,i[8]=e.sceneCenter.z}static parseSectionHeaders(e,t,s=0,n){const r=e.compressionLevel,i=e.maxSectionCount,o=new Uint16Array(t,s,i*D.SectionHeaderSizeBytes/2),a=new Uint32Array(t,s,i*D.SectionHeaderSizeBytes/4),l=new Float32Array(t,s,i*D.SectionHeaderSizeBytes/4),c=[];let h=0,d=h/2,p=h/4,u=D.HeaderSizeBytes+e.maxSectionCount*D.SectionHeaderSizeBytes,A=0;for(let e=0;e<i;e++){const t=a[p+1],s=a[p+2],i=a[p+3],m=l[p+4],g=m/2,f=o[d+10],C=a[p+6]||D.CompressionLevels[r].ScaleRange,S=a[p+8],y=a[p+9],x=4*y,I=f*i+x,v=o[d+20],{bytesPerSplat:B}=D.calculateComponentStorage(r,v),w=B*t,b=w+I,E={bytesPerSplat:B,splatCountOffset:A,splatCount:n?t:0,maxSplatCount:t,bucketSize:s,bucketCount:i,bucketBlockSize:m,halfBucketBlockSize:g,bucketStorageSizeBytes:f,bucketsStorageSizeBytes:I,splatDataStorageSizeBytes:w,storageSizeBytes:b,compressionScaleRange:C,compressionScaleFactor:g/C,base:u,bucketsBase:u+x,dataBase:u+I,fullBucketCount:S,partiallyFilledBucketCount:y,sphericalHarmonicsDegree:v};c[e]=E,u+=b,h+=D.SectionHeaderSizeBytes,d=h/2,p=h/4,A+=t}return c}static writeSectionHeaderToBuffer(e,t,s,n=0){const r=new Uint16Array(s,n,D.SectionHeaderSizeBytes/2),i=new Uint32Array(s,n,D.SectionHeaderSizeBytes/4),o=new Float32Array(s,n,D.SectionHeaderSizeBytes/4);i[0]=e.splatCount,i[1]=e.maxSplatCount,i[2]=t>=1?e.bucketSize:0,i[3]=t>=1?e.bucketCount:0,o[4]=t>=1?e.bucketBlockSize:0,r[10]=t>=1?D.BucketStorageSizeBytes:0,i[6]=t>=1?e.compressionScaleRange:0,i[7]=e.storageSizeBytes,i[8]=t>=1?e.fullBucketCount:0,i[9]=t>=1?e.partiallyFilledBucketCount:0,r[20]=e.sphericalHarmonicsDegree}static writeSectionHeaderSplatCountToBuffer(e,t,s=0){new Uint32Array(t,s,D.SectionHeaderSizeBytes/4)[0]=e}constructFromBuffer(e,t){this.bufferData=e,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSectionMap=[];const s=D.parseHeader(this.bufferData);this.versionMajor=s.versionMajor,this.versionMinor=s.versionMinor,this.maxSectionCount=s.maxSectionCount,this.sectionCount=t?s.maxSectionCount:0,this.maxSplatCount=s.maxSplatCount,this.splatCount=t?s.maxSplatCount:0,this.compressionLevel=s.compressionLevel,this.sceneCenter=(new n.Vector3).copy(s.sceneCenter),this.sections=D.parseSectionHeaders(s,this.bufferData,D.HeaderSizeBytes,t),this.linkBufferArrays(),this.buildMaps()}static calculateComponentStorage(e,t){const s=D.CompressionLevels[e].BytesPerCenter,n=D.CompressionLevels[e].BytesPerScale,r=D.CompressionLevels[e].BytesPerRotation,i=D.CompressionLevels[e].BytesPerColor,o=p(t),a=D.CompressionLevels[e].BytesPerSphericalHarmonicsComponent*o;return{bytesPerCenter:s,bytesPerScale:n,bytesPerRotation:r,bytesPerColor:i,sphericalHarmonicsComponentsPerSplat:o,sphericalHarmonicsBytesPerSplat:a,bytesPerSplat:s+n+r+i+a}}linkBufferArrays(){for(let e=0;e<this.maxSectionCount;e++){const t=this.sections[e];t.bucketArray=new Float32Array(this.bufferData,t.bucketsBase,t.bucketCount*D.BucketStorageSizeFloats),t.partiallyFilledBucketCount>0&&(t.partiallyFilledBucketLengths=new Uint32Array(this.bufferData,t.base,t.partiallyFilledBucketCount))}}buildMaps(){let e=0;for(let t=0;t<this.maxSectionCount;t++){const s=this.sections[t];for(let n=0;n<s.maxSplatCount;n++){const s=e+n;this.globalSplatIndexToLocalSplatIndexMap[s]=n,this.globalSplatIndexToSectionMap[s]=t}e+=s.maxSplatCount}}updateLoadedCounts(e,t){D.writeHeaderCountsToBuffer(e,t,this.bufferData),this.sectionCount=e,this.splatCount=t}updateSectionLoadedCounts(e,t){const s=D.HeaderSizeBytes+D.SectionHeaderSizeBytes*e;D.writeSectionHeaderSplatCountToBuffer(t,this.bufferData,s),this.sections[e].splatCount=t}static writeSplatDataToSectionBuffer=function(){const e=new ArrayBuffer(12),t=new ArrayBuffer(12),s=new ArrayBuffer(16),r=new ArrayBuffer(4),i=new ArrayBuffer(256),o=new n.Quaternion,a=new n.Vector3,c=new n.Vector3,{X:h,Y:d,Z:u,SCALE0:A,SCALE1:m,SCALE2:g,ROTATION0:f,ROTATION1:S,ROTATION2:y,ROTATION3:v,FDC0:B,FDC1:w,FDC2:b,OPACITY:T,FRC0:M,FRC9:F}=C.OFFSET,R=(e,t,s)=>{const n=2*s+1;return e=Math.round(e*t)+s,l(e,0,n)};return function(n,l,C,P,k,H,L,O){const _=p(k),U=C,Q=U+D.CompressionLevels[P].BytesPerCenter,z=Q+D.CompressionLevels[P].BytesPerScale,V=z+D.CompressionLevels[P].BytesPerRotation,N=V+D.CompressionLevels[P].BytesPerColor;if(void 0!==n[f]?(o.set(n[f],n[S],n[y],n[v]),o.normalize()):o.set(1,0,0,0),void 0!==n[A]?a.set(n[A],n[m],n[g]):a.set(.01,.01,.01),0===P){const e=new Float32Array(l,U,D.CenterComponentCount),t=new Float32Array(l,z,D.RotationComponentCount),s=new Float32Array(l,Q,D.ScaleComponentCount);if(t.set([o.x,o.y,o.z,o.w]),s.set([a.x,a.y,a.z]),e.set([n[h],n[d],n[u]]),k>0){const e=new Float32Array(l,N,_);if(k>=1){for(let t=0;t<9;t++)e[t]=n[M+t]||0;if(k>=2)for(let t=0;t<15;t++)e[t+9]=n[F+t]||0}}}else{const r=new Uint16Array(e,0,D.CenterComponentCount),p=new Uint16Array(s,0,D.RotationComponentCount),A=new Uint16Array(t,0,D.ScaleComponentCount);if(p.set([x(o.x),x(o.y),x(o.z),x(o.w)]),A.set([x(a.x),x(a.y),x(a.z)]),c.set(n[h],n[d],n[u]).sub(H),c.x=R(c.x,L,O),c.y=R(c.y,L,O),c.z=R(c.z,L,O),r.set([c.x,c.y,c.z]),k>0){const e=1===P?2:1,t=new(1===P?Uint16Array:Uint8Array)(i,0,_);if(k>=1){for(let e=0;e<9;e++){const s=n[M+e]||0;t[e]=1===P?x(s):I(s)}const s=9*e;if(E(t.buffer,0,l,N,s),k>=2){for(let e=0;e<15;e++){const s=n[F+e]||0;t[e+9]=1===P?x(s):I(s)}E(t.buffer,s,l,N+s,15*e)}}}E(r.buffer,0,l,U,6),E(A.buffer,0,l,Q,6),E(p.buffer,0,l,z,8)}const G=new Uint8ClampedArray(r,0,4);G.set([n[B]||0,n[w]||0,n[b]||0]),G[3]=n[T]||0,E(G.buffer,0,l,V,4)}}();static generateFromUncompressedSplatArrays(e,t,s,r,i,o,a=[]){let l=0;for(let t=0;t<e.length;t++){const s=e[t];l=Math.max(s.sphericalHarmonicsDegree,l)}const{bytesPerSplat:c}=D.calculateComponentStorage(s,l),h=D.CompressionLevels[s].ScaleRange,d=[],p=[];let u=0;for(let r=0;r<e.length;r++){const A=e[r],m=new C(l);for(let e=0;e<A.splatCount;e++){const s=A.splats[e];(s[C.OFFSET.OPACITY]||0)>=t&&m.addSplat(s)}const g=a[r]||{},f=(g.blockSizeFactor||1)*(i||D.BucketBlockSize),S=Math.ceil((g.bucketSizeFactor||1)*(o||D.BucketSize)),y=D.computeBucketsForUncompressedSplatArray(m,f,S),x=y.fullBuckets.length,I=y.partiallyFullBuckets.map((e=>e.splats.length)),v=I.length,B=[...y.fullBuckets,...y.partiallyFullBuckets],w=m.splats.length*c,b=4*v,E=s>=1?B.length*D.BucketStorageSizeBytes+b:0,T=w+E,M=new ArrayBuffer(T),F=h/(.5*f),R=new n.Vector3;let P=0;for(let e=0;e<B.length;e++){const t=B[e];R.fromArray(t.center);for(let e=0;e<t.splats.length;e++){let n=t.splats[e];const r=m.splats[n],i=E+P*c;D.writeSplatDataToSectionBuffer(r,M,i,s,l,R,F,h),P++}}if(u+=P,s>=1){const e=new Uint32Array(M,0,4*I.length);for(let t=0;t<I.length;t++)e[t]=I[t];const t=new Float32Array(M,b,B.length*D.BucketStorageSizeFloats);for(let e=0;e<B.length;e++){const s=B[e],n=3*e;t[n]=s.center[0],t[n+1]=s.center[1],t[n+2]=s.center[2]}}d.push(M);const k=new ArrayBuffer(D.SectionHeaderSizeBytes);D.writeSectionHeaderToBuffer({maxSplatCount:P,splatCount:P,bucketSize:S,bucketCount:B.length,bucketBlockSize:f,compressionScaleRange:h,storageSizeBytes:T,fullBucketCount:x,partiallyFilledBucketCount:v,sphericalHarmonicsDegree:l},s,k,0),p.push(k)}let A=0;for(let e of d)A+=e.byteLength;const m=D.HeaderSizeBytes+D.SectionHeaderSizeBytes*d.length+A,g=new ArrayBuffer(m);D.writeHeaderToBuffer({versionMajor:0,versionMinor:1,maxSectionCount:d.length,sectionCount:d.length,maxSplatCount:u,splatCount:u,compressionLevel:s,sceneCenter:r},g);let f=D.HeaderSizeBytes;for(let e of p)new Uint8Array(g,f,D.SectionHeaderSizeBytes).set(new Uint8Array(e)),f+=D.SectionHeaderSizeBytes;for(let e of d)new Uint8Array(g,f,e.byteLength).set(new Uint8Array(e)),f+=e.byteLength;return new D(g)}static computeBucketsForUncompressedSplatArray(e,t,s){let r=e.splatCount;const i=t/2,o=new n.Vector3,a=new n.Vector3;for(let t=0;t<r;t++){const s=e.splats[t],n=[s[C.OFFSET.X],s[C.OFFSET.Y],s[C.OFFSET.Z]];(0===t||n[0]<o.x)&&(o.x=n[0]),(0===t||n[0]>a.x)&&(a.x=n[0]),(0===t||n[1]<o.y)&&(o.y=n[1]),(0===t||n[1]>a.y)&&(a.y=n[1]),(0===t||n[2]<o.z)&&(o.z=n[2]),(0===t||n[2]>a.z)&&(a.z=n[2])}const l=(new n.Vector3).copy(a).sub(o),c=Math.ceil(l.y/t),h=Math.ceil(l.z/t),d=new n.Vector3,p=[],u={};for(let n=0;n<r;n++){const r=e.splats[n],a=[r[C.OFFSET.X],r[C.OFFSET.Y],r[C.OFFSET.Z]],l=Math.floor((a[0]-o.x)/t),A=Math.floor((a[1]-o.y)/t),m=Math.floor((a[2]-o.z)/t);d.x=l*t+o.x+i,d.y=A*t+o.y+i,d.z=m*t+o.z+i;const g=l*(c*h)+A*h+m;let f=u[g];f||(u[g]=f={splats:[],center:d.toArray()}),f.splats.push(n),f.splats.length>=s&&(p.push(f),u[g]=null)}const A=[];for(let e in u)if(u.hasOwnProperty(e)){const t=u[e];t&&A.push(t)}return{fullBuckets:p,partiallyFullBuckets:A}}}const T=new Uint8Array([112,108,121,10]),M=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),F="end_header",R=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]),P=(e,t)=>{const s=(1<<t)-1;return(e&s)/s},k=(e,t)=>{e.x=P(t>>>21,11),e.y=P(t>>>11,10),e.z=P(t,11)},H=(e,t,s)=>e*(1-s)+t*s,L=(e,t)=>e.properties.find((e=>e.name===t&&e.storage))?.storage;class O{static decodeHeaderText(e){let t,s,n;const r=e.split("\n").filter((e=>!e.startsWith("comment ")));let i=0,o=!1;for(let e=1;e<r.length;++e){const a=r[e].split(" ");switch(a[0]){case"format":if("binary_little_endian"!==a[1])throw new Error("Unsupported ply format");break;case"element":t={name:a[1],count:parseInt(a[2],10),properties:[],storageSizeBytes:0},"chunk"===t.name?s=t:"vertex"===t.name&&(n=t);break;case"property":{if(!R.has(a[1]))throw new Error(`Unrecognized property data type '${a[1]}' in ply header`);const e=R.get(a[1]),s=e.BYTES_PER_ELEMENT*t.count;"vertex"===t.name&&(i+=e.BYTES_PER_ELEMENT),t.properties.push({type:a[1],name:a[2],storage:null,byteSize:e.BYTES_PER_ELEMENT,storageSizeByes:s}),t.storageSizeBytes+=s;break}case F:o=!0;break;default:throw new Error(`Unrecognized header value '${a[0]}' in ply header`)}if(o)break}return{chunkElement:s,vertexElement:n,bytesPerSplat:i,headerSizeBytes:e.indexOf(F)+10+1,sphericalHarmonicsDegree:0}}static decodeHeader(e){let t,s=new Uint8Array(e);if(s.length>=T.length&&!((e,t)=>{if(e.length<t.length)return!1;for(let s=0;s<t.length;++s)if(e[s]!==t[s])return!1;return!0})(s,T))throw new Error("Invalid PLY header");if(t=((e,t)=>{const s=e.length-t.length;let n,r;for(n=0;n<=s;++n){for(r=0;r<t.length&&e[n+r]===t[r];++r);if(r===t.length)return n}return-1})(s,M),-1===t)throw new Error("End of PLY header not found");const n=new TextDecoder("ascii").decode(s.slice(0,t)),{chunkElement:r,vertexElement:i,bytesPerSplat:o}=O.decodeHeaderText(n);return{headerSizeBytes:t+M.length,bytesPerSplat:o,chunkElement:r,vertexElement:i}}static readElementData(e,t,s,n,r,i=null){let o=t instanceof DataView?t:new DataView(t);n=n||0,r=r||e.count-1;for(let t=n;t<=r;++t)for(let n=0;n<e.properties.length;++n){const r=e.properties[n],a=R.get(r.type),l=a.BYTES_PER_ELEMENT*e.count;if(r.storage&&!(r.storage.byteLength<l)||i&&!i(r.name)||(r.storage=new a(e.count)),r.storage)switch(r.type){case"char":r.storage[t]=o.getInt8(s);break;case"uchar":r.storage[t]=o.getUint8(s);break;case"short":r.storage[t]=o.getInt16(s,!0);break;case"ushort":r.storage[t]=o.getUint16(s,!0);break;case"int":r.storage[t]=o.getInt32(s,!0);break;case"uint":r.storage[t]=o.getUint32(s,!0);break;case"float":r.storage[t]=o.getFloat32(s,!0);break;case"double":r.storage[t]=o.getFloat64(s,!0)}s+=r.byteSize}return s}static readPly(e,t=null){const s=O.decodeHeader(e);let n=O.readElementData(s.chunkElement,e,s.headerSizeBytes,null,null,t);return O.readElementData(s.vertexElement,e,n,null,null,t),{chunkElement:s.chunkElement,vertexElement:s.vertexElement}}static getElementStorageArrays(e,t){const s=L(e,"min_x"),n=L(e,"min_y"),r=L(e,"min_z"),i=L(e,"max_x"),o=L(e,"max_y"),a=L(e,"max_z"),l=L(e,"min_scale_x"),c=L(e,"min_scale_y"),h=L(e,"min_scale_z");return{positionExtremes:{minX:s,maxX:i,minY:n,maxY:o,minZ:r,maxZ:a},scaleExtremes:{minScaleX:l,maxScaleX:L(e,"max_scale_x"),minScaleY:c,maxScaleY:L(e,"max_scale_y"),minScaleZ:h,maxScaleZ:L(e,"max_scale_z")},position:L(t,"packed_position"),rotation:L(t,"packed_rotation"),scale:L(t,"packed_scale"),color:L(t,"packed_color")}}static decompressSplat=function(){const e=new n.Vector3,t=new n.Quaternion,s=new n.Vector3,r=new n.Vector4,i=C.OFFSET;return function(n,o,a,c,h,d,p,u,A){A=A||C.createSplat();const m=Math.floor((o+n)/256);var g,f;return k(e,a[n]),((e,t)=>{const s=1/(.5*Math.sqrt(2)),n=(P(t>>>20,10)-.5)*s,r=(P(t>>>10,10)-.5)*s,i=(P(t,10)-.5)*s,o=Math.sqrt(1-(n*n+r*r+i*i));switch(t>>>30){case 0:e.set(o,n,r,i);break;case 1:e.set(n,o,r,i);break;case 2:e.set(n,r,o,i);break;case 3:e.set(n,r,i,o)}})(t,p[n]),k(s,h[n]),g=r,f=u[n],g.x=P(f>>>24,8),g.y=P(f>>>16,8),g.z=P(f>>>8,8),g.w=P(f,8),A[i.X]=H(c.minX[m],c.maxX[m],e.x),A[i.Y]=H(c.minY[m],c.maxY[m],e.y),A[i.Z]=H(c.minZ[m],c.maxZ[m],e.z),A[i.ROTATION0]=t.x,A[i.ROTATION1]=t.y,A[i.ROTATION2]=t.z,A[i.ROTATION3]=t.w,A[i.SCALE0]=Math.exp(H(d.minScaleX[m],d.maxScaleX[m],s.x)),A[i.SCALE1]=Math.exp(H(d.minScaleY[m],d.maxScaleY[m],s.y)),A[i.SCALE2]=Math.exp(H(d.minScaleZ[m],d.maxScaleZ[m],s.z)),A[i.FDC0]=l(Math.floor(255*r.x),0,255),A[i.FDC1]=l(Math.floor(255*r.y),0,255),A[i.FDC2]=l(Math.floor(255*r.z),0,255),A[i.OPACITY]=l(Math.floor(255*r.w),0,255),A}}();static parseToUncompressedSplatBufferSection(e,t,s,n,r,i,o,a,l,c=null){O.readElementData(t,i,o,s,n,c);const h=D.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,{positionExtremes:d,scaleExtremes:p,position:u,rotation:A,scale:m,color:g}=O.getElementStorageArrays(e,t),f=C.createSplat();for(let e=s;e<=n;++e){O.decompressSplat(e,r,u,d,m,p,A,g,f);const t=e*h+l;D.writeSplatDataToSectionBuffer(f,a,t,0,0)}}static parseToUncompressedSplatArray(e){const{chunkElement:t,vertexElement:s}=O.readPly(e),r=new C,{positionExtremes:i,scaleExtremes:o,position:a,rotation:l,scale:c,color:h}=O.getElementStorageArrays(t,s);for(let e=0;e<s.count;++e){r.addDefaultSplat();const t=r.getSplat(r.splatCount-1);O.decompressSplat(e,0,a,i,c,o,l,h,t)}return(new n.Matrix4).identity(),r}}const _=0,U=1,Q=2,[z,V,N,G,K,j,W]=[0,1,2,3,4,5,6],q={double:z,int:V,uint:N,float:G,short:K,ushort:j,uchar:W},Y={[z]:8,[V]:4,[N]:4,[G]:4,[K]:2,[j]:2,[W]:1};class X{static HeaderEndToken="end_header";constructor(){}decodeSectionHeader(e,t,s=0){const n=[];let r=!1,i=-1,o=0,a=!1,l=null;const c=[],h=[],d=[],p=[],u={};for(let A=s;A<e.length;A++){const m=e[A].trim();if(m.startsWith("element")){if(r){i--;break}{r=!0,s=A,i=A;const e=m.split(" ");let t=0;for(let s of e){const e=s.trim();e.length>0&&(t++,2===t?l=e:3===t&&(o=parseInt(e)))}}}else if(m.startsWith("property")){const e=m.match(/(\w+)\s+(\w+)\s+(\w+)/);if(e){const s=e[2],n=e[3];d.push(n);const r=t[n];u[n]=s;const i=q[s];void 0!==r&&(p.push(n),c.push(r),h[r]=i)}}if(m===X.HeaderEndToken){a=!0;break}r&&(n.push(m),i++)}const A=[];let m=0;for(let e of d){const s=u[e];if(u.hasOwnProperty(e)){const s=t[e];void 0!==s&&(A[s]=m)}m+=Y[q[s]]}const g=this.decodeSphericalHarmonicsFromSectionHeader(d,t);return{headerLines:n,headerStartLine:s,headerEndLine:i,fieldTypes:h,fieldIds:c,fieldOffsets:A,bytesPerVertex:m,vertexCount:o,dataSizeBytes:m*o,endOfHeader:a,sectionName:l,sphericalHarmonicsDegree:g.degree,sphericalHarmonicsCoefficientsPerChannel:g.coefficientsPerChannel,sphericalHarmonicsDegree1Fields:g.degree1Fields,sphericalHarmonicsDegree2Fields:g.degree2Fields}}decodeSphericalHarmonicsFromSectionHeader(e,t){let s=0,n=0;for(let t of e)t.startsWith("f_rest")&&s++;n=s/3;let r=0;n>=3&&(r=1),n>=8&&(r=2);let i=[],o=[];for(let e=0;e<3;e++){if(r>=1)for(let s=0;s<3;s++)i.push(t["f_rest_"+(s+n*e)]);if(r>=2)for(let s=0;s<5;s++)o.push(t["f_rest_"+(s+n*e+3)])}return{degree:r,coefficientsPerChannel:n,degree1Fields:i,degree2Fields:o}}static getHeaderSectionNames(e){const t=[];for(let s of e)if(s.startsWith("element")){const e=s.split(" ");let n=0;for(let s of e){const e=s.trim();e.length>0&&(n++,2===n&&t.push(e))}}return t}static checkTextForEndHeader(e){return!!e.includes(X.HeaderEndToken)}static checkBufferForEndHeader(e,t,s,n){const r=new Uint8Array(e,Math.max(0,t-s),s),i=n.decode(r);return X.checkTextForEndHeader(i)}static extractHeaderFromBufferToText(e){const t=new TextDecoder;let s=0,n="";const r=100;for(;;){if(s+r>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,s,r);if(n+=t.decode(i),s+=r,X.checkBufferForEndHeader(e,s,200,t))break}return n}readHeaderFromBuffer(e){const t=new TextDecoder;let s=0,n="";const r=100;for(;;){if(s+r>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,s,r);if(n+=t.decode(i),s+=r,X.checkBufferForEndHeader(e,s,200,t))break}return n}static convertHeaderTextToLines(e){const t=e.split("\n"),s=[];for(let e=0;e<t.length;e++){const n=t[e].trim();if(s.push(n),n===X.HeaderEndToken)break}return s}static determineHeaderFormatFromHeaderText(e){const t=X.convertHeaderTextToLines(e);let s=_;for(let e=0;e<t.length;e++){const n=t[e].trim();if(n.startsWith("element chunk")||n.match(/[A-Za-z]*packed_[A-Za-z]*/))s=Q;else if(n.startsWith("element codebook_centers"))s=U;else if(n===X.HeaderEndToken)break}return s}static determineHeaderFormatFromPlyBuffer(e){const t=X.extractHeaderFromBufferToText(e);return X.determineHeaderFormatFromHeaderText(t)}static readVertex(e,t,s,n,r,i,o=!0){const a=s*t.bytesPerVertex+n,l=t.fieldOffsets,c=t.fieldTypes;for(let t of r){const s=c[t];s===G?i[t]=e.getFloat32(a+l[t],!0):s===K?i[t]=e.getInt16(a+l[t],!0):s===j?i[t]=e.getUint16(a+l[t],!0):s===V?i[t]=e.getInt32(a+l[t],!0):s===N?i[t]=e.getUint32(a+l[t],!0):s===W&&(i[t]=o?e.getUint8(a+l[t])/255:e.getUint8(a+l[t]))}}}const J=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0","f_rest_1","f_rest_2","f_rest_15","f_rest_16","f_rest_17","f_rest_30","f_rest_31","f_rest_32","f_rest_3","f_rest_4","f_rest_5","f_rest_6","f_rest_7","f_rest_18","f_rest_19","f_rest_20","f_rest_21","f_rest_22","f_rest_33","f_rest_34","f_rest_35","f_rest_36","f_rest_37"],Z=J.map(((e,t)=>t)),[$,ee,te,se,ne,re,ie,oe,ae,le,ce,he,de,pe,ue,Ae,me,ge]=Z;class fe{constructor(){this.plyParserutils=new X}decodeHeaderLines(e){const t=Z.reduce(((e,t)=>(e[J[t]]=t,e)),{}),s=this.plyParserutils.decodeSectionHeader(e,t,0);return s.splatCount=s.vertexCount,s.bytesPerSplat=s.bytesPerVertex,s}decodeHeaderText(e){const t=X.convertHeaderTextToLines(e),s=this.decodeHeaderLines(t);return s.headerText=e,s.headerSizeBytes=e.indexOf(X.HeaderEndToken)+X.HeaderEndToken.length+1,s}decodeHeaderFromBuffer(e){const t=this.plyParserutils.readHeaderFromBuffer(e);return this.decodeHeaderText(t)}findSplatData(e,t){return new DataView(e,t.headerSizeBytes)}parseToUncompressedSplatBufferSection(e,t,s,n,r,i,o,a=0){a=Math.min(a,e.sphericalHarmonicsDegree);const l=D.CompressionLevels[0].SphericalHarmonicsDegrees[a].BytesPerSplat;for(let c=t;c<=s;c++){const t=fe.parseToUncompressedSplat(n,c,e,r,a),s=c*l+o;D.writeSplatDataToSectionBuffer(t,i,s,0,a)}}decodeSectionSplatData(e,t,s,n){n=Math.min(n,s.sphericalHarmonicsDegree);const r=new C(n);for(let i=0;i<t;i++){const t=fe.parseToUncompressedSplat(e,i,s,0,n);r.addSplat(t)}return r}static parseToUncompressedSplat=function(){let e=[];const t=new n.Quaternion,s=C.OFFSET.X,r=C.OFFSET.Y,i=C.OFFSET.Z,o=C.OFFSET.SCALE0,a=C.OFFSET.SCALE1,c=C.OFFSET.SCALE2,h=C.OFFSET.ROTATION0,d=C.OFFSET.ROTATION1,p=C.OFFSET.ROTATION2,u=C.OFFSET.ROTATION3,A=C.OFFSET.FDC0,m=C.OFFSET.FDC1,g=C.OFFSET.FDC2,f=C.OFFSET.OPACITY,S=[];for(let e=0;e<45;e++)S[e]=C.OFFSET.FRC0+e;return function(n,y,x,I=0,v=0){v=Math.min(v,x.sphericalHarmonicsDegree),fe.readSplat(n,x,y,I,e);const B=C.createSplat(v);if(void 0!==e[$]?(B[o]=Math.exp(e[$]),B[a]=Math.exp(e[ee]),B[c]=Math.exp(e[te])):(B[o]=.01,B[a]=.01,B[c]=.01),void 0!==e[ce]){const t=.28209479177387814;B[A]=255*(.5+t*e[ce]),B[m]=255*(.5+t*e[he]),B[g]=255*(.5+t*e[de])}else void 0!==e[ue]?(B[A]=255*e[ue],B[m]=255*e[Ae],B[g]=255*e[me]):(B[A]=0,B[m]=0,B[g]=0);if(void 0!==e[pe]&&(B[f]=1/(1+Math.exp(-e[pe]))*255),B[A]=l(Math.floor(B[A]),0,255),B[m]=l(Math.floor(B[m]),0,255),B[g]=l(Math.floor(B[g]),0,255),B[f]=l(Math.floor(B[f]),0,255),v>=1&&void 0!==e[ge]){for(let t=0;t<9;t++)B[S[t]]=e[x.sphericalHarmonicsDegree1Fields[t]];if(v>=2)for(let t=0;t<15;t++)B[S[9+t]]=e[x.sphericalHarmonicsDegree2Fields[t]]}return t.set(e[se],e[ne],e[re],e[ie]),t.normalize(),B[h]=t.x,B[d]=t.y,B[p]=t.z,B[u]=t.w,B[s]=e[oe],B[r]=e[ae],B[i]=e[le],B}}();static readSplat(e,t,s,n,r){return X.readVertex(e,t,s,n,Z,r,!0)}parseToUncompressedSplatArray(e,t=0){const s=this.decodeHeaderFromBuffer(e),n=s.splatCount,r=this.findSplatData(e,s);return this.decodeSectionSplatData(r,n,s,t)}}const Ce=["features_dc","features_rest_0","features_rest_1","features_rest_2","features_rest_3","features_rest_4","features_rest_5","features_rest_6","features_rest_7","features_rest_8","features_rest_9","features_rest_10","features_rest_11","features_rest_12","features_rest_13","features_rest_14","opacity","scaling","rotation_re","rotation_im"],Se=Ce.map(((e,t)=>t)),[ye,xe,Ie,ve,Be,we,be]=[0,1,4,16,17,18,19],Ee=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0","f_rest_1","f_rest_2","f_rest_3","f_rest_4","f_rest_5","f_rest_6","f_rest_7","f_rest_8","f_rest_9","f_rest_10","f_rest_11","f_rest_12","f_rest_13","f_rest_14","f_rest_15","f_rest_16","f_rest_17","f_rest_18","f_rest_19","f_rest_20","f_rest_21","f_rest_22","f_rest_23","f_rest_24","f_rest_25","f_rest_26","f_rest_27","f_rest_28","f_rest_29","f_rest_30","f_rest_31","f_rest_32","f_rest_33","f_rest_34","f_rest_35","f_rest_36","f_rest_37","f_rest_38","f_rest_39","f_rest_40","f_rest_41","f_rest_42","f_rest_43","f_rest_44","f_rest_45"],De=Ee.map(((e,t)=>t)),[Te,Me,Fe,Re,Pe,ke,He,Le,Oe,_e,Ue,Qe,ze,Ve]=De,Ne=Ue,Ge=Qe,Ke=ze,je=e=>{const t=(31744&e)>>10,s=1023&e;return(e>>15?-1:1)*(t?31===t?s?NaN:1/0:Math.pow(2,t-15)*(1+s/1024):s/1024*6103515625e-14)};class We{constructor(){this.plyParserutils=new X}decodeSectionHeadersFromHeaderLines(e){const t=De.reduce(((e,t)=>(e[Ee[t]]=t,e)),{}),s=Se.reduce(((e,t)=>(e[Ce[t]]=t,e)),{}),n=X.getHeaderSectionNames(e);let r;for(let e=0;e<n.length;e++){"codebook_centers"===n[e]&&(r=e)}let i=0,o=!1;const a=[];let l=0;for(;!o;){let n;n=l===r?this.plyParserutils.decodeSectionHeader(e,s,i):this.plyParserutils.decodeSectionHeader(e,t,i),o=n.endOfHeader,i=n.headerEndLine+1,o||(n.splatCount=n.vertexCount,n.bytesPerSplat=n.bytesPerVertex),a.push(n),l++}return a}decodeSectionHeadersFromHeaderText(e){const t=X.convertHeaderTextToLines(e);return this.decodeSectionHeadersFromHeaderLines(t)}getSplatCountFromSectionHeaders(e){let t=0;for(let s of e)"codebook_centers"!==s.sectionName&&(t+=s.vertexCount);return t}decodeHeaderFromHeaderText(e){const t=e.indexOf(X.HeaderEndToken)+X.HeaderEndToken.length+1,s=this.decodeSectionHeadersFromHeaderText(e);return{headerSizeBytes:t,sectionHeaders:s,splatCount:this.getSplatCountFromSectionHeaders(s)}}decodeHeaderFromBuffer(e){const t=this.plyParserutils.readHeaderFromBuffer(e);return this.decodeHeaderFromHeaderText(t)}findVertexData(e,t,s){let n=t.headerSizeBytes;for(let e=0;e<s&&e<t.sectionHeaders.length;e++){n+=t.sectionHeaders[e].dataSizeBytes}return new DataView(e,n,t.sectionHeaders[s].dataSizeBytes)}decodeCodeBook(e,t){const s=[],n=[];for(let r=0;r<t.vertexCount;r++){X.readVertex(e,t,r,0,Se,s);for(let e of Se){const t=Se[e];let r=n[t];r||(n[t]=r=[]),r.push(s[e])}}for(let e=0;e<n.length;e++){const t=n[e],s=.28209479177387814;for(let n=0;n<t.length;n++){const r=je(t[n]);t[n]=e===ve?Math.round(1/(1+Math.exp(-r))*255):e===ye?Math.round(255*(.5+s*r)):e===Be?Math.exp(r):r}}return n}decodeSectionSplatData(e,t,s,n,r){r=Math.min(r,s.sphericalHarmonicsDegree);const i=new C(r);for(let o=0;o<t;o++){const t=We.parseToUncompressedSplat(e,o,s,n,0,r);i.addSplat(t)}return i}static parseToUncompressedSplat=function(){let e=[];const t=new n.Quaternion,s=C.OFFSET.X,r=C.OFFSET.Y,i=C.OFFSET.Z,o=C.OFFSET.SCALE0,a=C.OFFSET.SCALE1,c=C.OFFSET.SCALE2,h=C.OFFSET.ROTATION0,d=C.OFFSET.ROTATION1,p=C.OFFSET.ROTATION2,u=C.OFFSET.ROTATION3,A=C.OFFSET.FDC0,m=C.OFFSET.FDC1,g=C.OFFSET.FDC2,f=C.OFFSET.OPACITY,S=[];for(let e=0;e<45;e++)S[e]=C.OFFSET.FRC0+e;return function(n,y,x,I,v=0,B=0){B=Math.min(B,x.sphericalHarmonicsDegree),We.readSplat(n,x,y,v,e);const w=C.createSplat(B);if(void 0!==e[Te]?(w[o]=I[Be][e[Te]],w[a]=I[Be][e[Me]],w[c]=I[Be][e[Fe]]):(w[o]=.01,w[a]=.01,w[c]=.01),void 0!==e[Ue]?(w[A]=I[ye][e[Ue]],w[m]=I[ye][e[Qe]],w[g]=I[ye][e[ze]]):void 0!==e[Ne]?(w[A]=255*e[Ne],w[m]=255*e[Ge],w[g]=255*e[Ke]):(w[A]=0,w[m]=0,w[g]=0),void 0!==e[Ve]&&(w[f]=I[ve][e[Ve]]),w[A]=l(Math.floor(w[A]),0,255),w[m]=l(Math.floor(w[m]),0,255),w[g]=l(Math.floor(w[g]),0,255),w[f]=l(Math.floor(w[f]),0,255),B>=1&&x.sphericalHarmonicsDegree>=1){for(let t=0;t<9;t++){const s=I[xe+t%3];w[S[t]]=s[e[x.sphericalHarmonicsDegree1Fields[t]]]}if(B>=2&&x.sphericalHarmonicsDegree>=2)for(let t=0;t<15;t++){const s=I[Ie+t%5];w[S[9+t]]=s[e[x.sphericalHarmonicsDegree2Fields[t]]]}}const b=I[we][e[Re]],E=I[be][e[Pe]],D=I[be][e[ke]],T=I[be][e[He]];return t.set(b,E,D,T),t.normalize(),w[h]=t.x,w[d]=t.y,w[p]=t.z,w[u]=t.w,w[s]=je(e[Le]),w[r]=je(e[Oe]),w[i]=je(e[_e]),w}}();static readSplat(e,t,s,n,r){return X.readVertex(e,t,s,n,De,r,!1)}parseToUncompressedSplatArray(e,t=0){const s=[],n=this.decodeHeaderFromBuffer(e,t);let r;for(let t=0;t<n.sectionHeaders.length;t++){const s=n.sectionHeaders[t];if("codebook_centers"===s.sectionName){const i=this.findVertexData(e,n,t);r=this.decodeCodeBook(i,s)}}for(let i=0;i<n.sectionHeaders.length;i++){const o=n.sectionHeaders[i];if("codebook_centers"!==o.sectionName){const a=o.vertexCount,l=this.findVertexData(e,n,i),c=this.decodeSectionSplatData(l,a,o,r,t);s.push(c)}}const i=new C(t);for(let e of s)for(let t of e.splats)i.addSplat(t);return i}}class qe{static parseToUncompressedSplatArray(e,t=0){const s=X.determineHeaderFormatFromPlyBuffer(e);return s===Q?O.parseToUncompressedSplatArray(e):s===_?(new fe).parseToUncompressedSplatArray(e,t):s===U?(new We).parseToUncompressedSplatArray(e,t):void 0}}class Ye{constructor(e,t,s,n){this.sectionCount=e,this.sectionFilters=t,this.groupingParameters=s,this.partitionGenerator=n}partitionUncompressedSplatArray(e){let t,s,n;if(this.partitionGenerator){const r=this.partitionGenerator(e);t=r.groupingParameters,s=r.sectionCount,n=r.sectionFilters}else t=this.groupingParameters,s=this.sectionCount,n=this.sectionFilters;const r=[];for(let t=0;t<s;t++){const s=new C(e.sphericalHarmonicsDegree),i=n[t];for(let t=0;t<e.splatCount;t++)i(t)&&s.addSplatFromArray(e,t);r.push(s)}return{splatArrays:r,parameters:t}}static getStandardPartitioner(e=0,t=new n.Vector3,s=D.BucketBlockSize,r=D.BucketSize){return new Ye(void 0,void 0,void 0,(i=>{const o=C.OFFSET.X,a=C.OFFSET.Y,l=C.OFFSET.Z;e<=0&&(e=i.splatCount);const c=new n.Vector3,h=.5;i.splats.forEach((e=>{var s;c.set(e[o],e[a],e[l]).sub(t),(s=c).x=Math.floor(s.x/h)*h,s.y=Math.floor(s.y/h)*h,s.z=Math.floor(s.z/h)*h,e.centerDist=c.lengthSq()})),i.splats.sort(((e,t)=>e.centerDist>t.centerDist?1:-1));const d=[],p=[];e=Math.min(i.splatCount,e);const u=Math.ceil(i.splatCount/e);let A=0;for(let t=0;t<u;t++){let t=A;d.push((s=>s>=t&&s<t+e)),p.push({blocksSize:s,bucketSize:r}),A+=e}return{sectionCount:d.length,sectionFilters:d,groupingParameters:p}}))}}class Xe{constructor(e,t,s,r,i,o,a){this.splatPartitioner=e,this.alphaRemovalThreshold=t,this.compressionLevel=s,this.sectionSize=r,this.sceneCenter=i?(new n.Vector3).copy(i):void 0,this.blockSize=o,this.bucketSize=a}generateFromUncompressedSplatArray(e){const t=this.splatPartitioner.partitionUncompressedSplatArray(e);return D.generateFromUncompressedSplatArrays(t.splatArrays,this.alphaRemovalThreshold,this.compressionLevel,this.sceneCenter,this.blockSize,this.bucketSize,t.parameters)}static getStandardGenerator(e=1,t=1,s=0,r=new n.Vector3,i=D.BucketBlockSize,o=D.BucketSize){const a=Ye.getStandardPartitioner(s,r,i,o);return new Xe(a,e,t,s,r,i,o)}}const Je=0,Ze=1,$e=2;function et(e,t){let s=0;for(let t of e)s+=t.sizeBytes;(!t||t.byteLength<s)&&(t=new ArrayBuffer(s));let n=0;for(let s of e)new Uint8Array(t,n,s.sizeBytes).set(s.data),n+=s.sizeBytes;return t}class tt{static loadFromURL(e,t,s,r,i,o,l=0,c,h,d,p){const A=S.ProgressiveLoadSectionSize,m=D.HeaderSizeBytes+D.SectionHeaderSizeBytes;let g,f,C,y,x=0,I=0,v=!1,B=!1,w=!1;const b=u();let E=0,T=0,M=0,F="",R=null,P=[];const k=new TextDecoder,H=new fe;return a(e,((e,i,o)=>{const a=e>=100;if(s){if(o&&(P.push({data:o,sizeBytes:o.byteLength,startBytes:M,endBytes:M+o.byteLength}),M+=o.byteLength),v){if(w&&!B){const e=R.headerSizeBytes+R.chunkElement.storageSizeBytes;y=et(P,y),y.byteLength>=e&&(O.readElementData(R.chunkElement,y,R.headerSizeBytes),E=e,T=e,B=!0)}}else if(F+=k.decode(o),X.checkTextForEndHeader(F)){const e=X.determineHeaderFormatFromHeaderText(F);if(e===_)R=H.decodeHeaderText(F),x=R.splatCount,B=!0,w=!1;else{if(e!==Q)throw new Error("PlyLoader.loadFromURL() -> Selected Ply format cannot be progressively loaded.");R=O.decodeHeaderText(F),x=R.vertexElement.count,w=!0}l=Math.min(l,R.sphericalHarmonicsDegree);const t=D.CompressionLevels[0].SphericalHarmonicsDegrees[l],s=m+t.BytesPerSplat*x;f=new ArrayBuffer(s),D.writeHeaderToBuffer({versionMajor:D.CurrentMajorVersion,versionMinor:D.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:x,splatCount:I,compressionLevel:0,sceneCenter:new n.Vector3},f),E=R.headerSizeBytes,T=R.headerSizeBytes,v=!0}if(v&&B){if(P.length>0){g=et(P,g);if(M-E>A||a){const e=M-T,t=Math.floor(e/R.bytesPerSplat),s=t*R.bytesPerSplat,n=e-s,i=I+t,o=T-P[0].startBytes,c=new DataView(g,o,s),h=D.CompressionLevels[0].SphericalHarmonicsDegrees[l],d=I*h.BytesPerSplat+m;if(w?O.parseToUncompressedSplatBufferSection(R.chunkElement,R.vertexElement,0,t-1,I,c,0,f,d):H.parseToUncompressedSplatBufferSection(R,0,t-1,c,0,f,d,l),I=i,C||(D.writeSectionHeaderToBuffer({maxSplatCount:x,splatCount:I,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:l},0,f,D.HeaderSizeBytes),C=new D(f,!1)),C.updateLoadedCounts(1,I),r(C,a),E+=A,T+=s,0===n)P=[];else{let e=[],t=0;for(let s=P.length-1;s>=0;s--){const r=P[s];if(t+=r.sizeBytes,e.unshift(r),t>=n)break}P=e}}}a&&b.resolve(C)}}t&&t(e,i,Je)}),!s).then((e=>{t&&t(0,"0%",Ze);return(s?b.promise:tt.loadFromFileData(e,i,o,l,c,h,d,p)).then((e=>(t&&t(100,"100%",$e),e)))}))}static loadFromFileData(e,t,s,n=0,r,i,o,a){return d((()=>qe.parseToUncompressedSplatArray(e,n))).then((e=>Xe.getStandardGenerator(t,s,r,i,o,a).generateFromUncompressedSplatArray(e)))}}class st{static RowSizeBytes=32;static CenterSizeBytes=12;static ScaleSizeBytes=12;static RotationSizeBytes=4;static ColorSizeBytes=4;static parseToUncompressedSplatBufferSection(e,t,s,r,i,o){const a=D.CompressionLevels[0].BytesPerCenter,l=D.CompressionLevels[0].BytesPerScale,c=D.CompressionLevels[0].BytesPerRotation,h=D.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;for(let d=e;d<=t;d++){const e=d*st.RowSizeBytes+r,t=new Float32Array(s,e,3),p=new Float32Array(s,e+st.CenterSizeBytes,3),u=new Uint8Array(s,e+st.CenterSizeBytes+st.ScaleSizeBytes,4),A=new Uint8Array(s,e+st.CenterSizeBytes+st.ScaleSizeBytes+st.RotationSizeBytes,4),m=new n.Quaternion((A[1]-128)/128,(A[2]-128)/128,(A[3]-128)/128,(A[0]-128)/128);m.normalize();const g=d*h+o,f=new Float32Array(i,g,3),C=new Float32Array(i,g+a,3),S=new Float32Array(i,g+a+l,4),y=new Uint8Array(i,g+a+l+c,4);f[0]=t[0],f[1]=t[1],f[2]=t[2],C[0]=p[0],C[1]=p[1],C[2]=p[2],S[0]=m.w,S[1]=m.x,S[2]=m.y,S[3]=m.z,y[0]=u[0],y[1]=u[1],y[2]=u[2],y[3]=u[3]}}static parseStandardSplatToUncompressedSplatArray(e){const t=e.byteLength/st.RowSizeBytes,s=new C;for(let r=0;r<t;r++){const t=r*st.RowSizeBytes,i=new Float32Array(e,t,3),o=new Float32Array(e,t+st.CenterSizeBytes,3),a=new Uint8Array(e,t+st.CenterSizeBytes+st.ScaleSizeBytes,4),l=new Uint8Array(e,t+st.CenterSizeBytes+st.ScaleSizeBytes+st.ColorSizeBytes,4),c=new n.Quaternion((l[1]-128)/128,(l[2]-128)/128,(l[3]-128)/128,(l[0]-128)/128);c.normalize(),s.addSplatFromComonents(i[0],i[1],i[2],o[0],o[1],o[2],c.w,c.x,c.y,c.z,a[0],a[1],a[2],a[3])}return s}}class nt{static loadFromURL(e,t,s,r,i,o,l,c,h,d,p){const A=D.HeaderSizeBytes+D.SectionHeaderSizeBytes,m=S.ProgressiveLoadSectionSize;let g,f,C,y=0,x=0;const I=u();let v=0,B=0,w=[];return a(e,((e,i,o,a)=>{const l=e>=100;if(a||(s=!1),s){if(!g){y=a/st.RowSizeBytes,g=new ArrayBuffer(a);const e=D.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;f=new ArrayBuffer(A+e*y),D.writeHeaderToBuffer({versionMajor:D.CurrentMajorVersion,versionMinor:D.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:y,splatCount:x,compressionLevel:0,sceneCenter:new n.Vector3},f)}if(o){w.push(o),new Uint8Array(g,B,o.byteLength).set(new Uint8Array(o)),B+=o.byteLength;const e=B-v;if(e>m||l){const t=(l?e:m)/st.RowSizeBytes,s=x+t;st.parseToUncompressedSplatBufferSection(x,s-1,g,0,f,A),x=s,C||(D.writeSectionHeaderToBuffer({maxSplatCount:y,splatCount:x,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,f,D.HeaderSizeBytes),C=new D(f,!1)),C.updateLoadedCounts(1,x),r(C,l),v+=m}}l&&I.resolve(C)}return t&&t(e,i,Je),s}),!0).then((e=>{t&&t(0,"0%",Ze);return(s?I.promise:nt.loadFromFileData(e,i,o,l,c,h,d,p)).then((e=>(t&&t(100,"100%",$e),e)))}))}static loadFromFileData(e,t,s,r,i,o,a,l){return d((()=>{const c=st.parseStandardSplatToUncompressedSplatArray(e);if(r){return Xe.getStandardGenerator(t,s,i,o,a,l).generateFromUncompressedSplatArray(c)}return D.generateFromUncompressedSplatArrays([c],t,0,new n.Vector3)}))}}class rt{static checkVersion(e){const t=D.CurrentMajorVersion,s=D.CurrentMinorVersion,n=D.parseHeader(e);if(n.versionMajor===t&&n.versionMinor>=s||n.versionMajor>t)return!0;throw new Error(`KSplat version not supported: v${n.versionMajor}.${n.versionMinor}. Minimum required: v${t}.${s}`)}static loadFromURL(e,t,s,n){let r,i,o,l,c,h=!1,d=!1,p=[],A=!1,m=!1,g=0,f=0,C=0,y=!1,x=!1,I=!1,v=[];const B=u();let w=0;const b=()=>{const e=()=>{m=!0;new Blob(v).arrayBuffer().then((e=>{m=!1,A=!0,c=new ArrayBuffer(l.maxSectionCount*D.SectionHeaderSizeBytes),new Uint8Array(c).set(new Uint8Array(e,D.HeaderSizeBytes,l.maxSectionCount*D.SectionHeaderSizeBytes)),p=D.parseSectionHeaders(l,c,0,!1);let t=0;for(let e=0;e<l.maxSectionCount;e++)t+=p[e].storageSizeBytes;const s=D.HeaderSizeBytes+l.maxSectionCount*D.SectionHeaderSizeBytes+t;if(!r){r=new ArrayBuffer(s);let e=0;for(let t=0;t<v.length;t++){const s=v[t];new Uint8Array(r,e,s.byteLength).set(new Uint8Array(s)),e+=s.byteLength}}C=D.HeaderSizeBytes+D.SectionHeaderSizeBytes*l.maxSectionCount;for(let e=0;e<=p.length&&e<l.maxSectionCount;e++)C+=p[e].storageSizeBytes;0===w&&(w++,window.setTimeout((()=>{w--,E()}),1))}))};!m&&!A&&h&&g>=D.HeaderSizeBytes+D.SectionHeaderSizeBytes*l.maxSectionCount&&e()},E=()=>{if(I)return;I=!0;window.setTimeout((()=>{if(I=!1,A){if(x)return;if(y=g>=C,g-f>S.ProgressiveLoadSectionSize||y){f+=S.ProgressiveLoadSectionSize,x=f>=C,i||(i=new D(r,!1));const e=D.HeaderSizeBytes+D.SectionHeaderSizeBytes*l.maxSectionCount;let s=0,o=0,a=0;for(let t=0;t<l.maxSectionCount;t++){const n=p[t],r=e+(s+4*n.partiallyFilledBucketCount+n.bucketStorageSizeBytes*n.bucketCount);if(!(f>=r))break;{o++;const e=f-r,s=D.CompressionLevels[l.compressionLevel].SphericalHarmonicsDegrees[n.sphericalHarmonicsDegree].BytesPerSplat;let c=Math.floor(e/s);c=Math.min(c,n.maxSplatCount),a+=c,i.updateLoadedCounts(o,a),i.updateSectionLoadedCounts(t,c)}s+=n.storageSizeBytes}n(i,x);const c=f/C*100,h=c.toFixed(2)+"%";t&&t(c,h,Je),x?B.resolve(i):E()}}}),S.ProgressiveLoadSectionDelayDuration)};return a(e,((e,n,i)=>{i&&(v.push(i),r&&new Uint8Array(r,g,i.byteLength).set(new Uint8Array(i)),g+=i.byteLength),s?(!h&&!d&&g>=D.HeaderSizeBytes&&(d=!0,new Blob(v).arrayBuffer().then((e=>{o=new ArrayBuffer(D.HeaderSizeBytes),new Uint8Array(o).set(new Uint8Array(e,0,D.HeaderSizeBytes)),rt.checkVersion(o),d=!1,h=!0,l=D.parseHeader(o),window.setTimeout((()=>{b()}),1)}))),b(),E()):t&&t(e,n,Je)}),!s).then((e=>{t&&t(0,"0%",Ze);return(s?B.promise:rt.loadFromFileData(e)).then((e=>(t&&t(100,"100%",$e),e)))}))}static loadFromFileData(e){return d((()=>(rt.checkVersion(e),new D(e))))}static downloadFile=function(){let e;return function(t,s){const n=new Blob([t.bufferData],{type:"application/octet-stream"});e||(e=document.createElement("a"),document.body.appendChild(e)),e.download=s,e.href=URL.createObjectURL(n),e.click()}}()}const it={Splat:0,KSplat:1,Ply:2},ot=e=>e.endsWith(".ply")?it.Ply:e.endsWith(".splat")?it.Splat:e.endsWith(".ksplat")?it.KSplat:null;var at=Object.freeze({__proto__:null,sceneFormatFromPath:ot});const lt={type:"change"},ct={type:"start"},ht={type:"end"},dt=new t.Ray,pt=new t.Plane,ut=Math.cos(70*t.MathUtils.DEG2RAD);class At extends t.EventDispatcher{constructor(e,s){super(),this.object=e,this.domElement=s,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new t.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:t.MOUSE.ROTATE,MIDDLE:t.MOUSE.DOLLY,RIGHT:t.MOUSE.PAN},this.touches={ONE:t.TOUCH.ROTATE,TWO:t.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",W),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",W),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,this.clearDampedRotation(),this.clearDampedPan(),n.object.updateProjectionMatrix(),n.dispatchEvent(lt),n.update(),i=r.NONE},this.clearDampedRotation=function(){l.theta=0,l.phi=0},this.clearDampedPan=function(){h.set(0,0,0)},this.update=function(){const s=new t.Vector3,d=(new t.Quaternion).setFromUnitVectors(e.up,new t.Vector3(0,1,0)),p=d.clone().invert(),u=new t.Vector3,A=new t.Quaternion,m=new t.Vector3,g=2*Math.PI;return function(){d.setFromUnitVectors(e.up,new t.Vector3(0,1,0)),p.copy(d).invert();const f=n.object.position;s.copy(f).sub(n.target),s.applyQuaternion(d),a.setFromVector3(s),n.autoRotate&&i===r.NONE&&b(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(a.theta+=l.theta*n.dampingFactor,a.phi+=l.phi*n.dampingFactor):(a.theta+=l.theta,a.phi+=l.phi);let C=n.minAzimuthAngle,S=n.maxAzimuthAngle;isFinite(C)&&isFinite(S)&&(C<-Math.PI?C+=g:C>Math.PI&&(C-=g),S<-Math.PI?S+=g:S>Math.PI&&(S-=g),a.theta=C<=S?Math.max(C,Math.min(S,a.theta)):a.theta>(C+S)/2?Math.max(C,a.theta):Math.min(S,a.theta)),a.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,a.phi)),a.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(h,n.dampingFactor):n.target.add(h),n.zoomToCursor&&I||n.object.isOrthographicCamera?a.radius=k(a.radius):a.radius=k(a.radius*c),s.setFromSpherical(a),s.applyQuaternion(p),f.copy(n.target).add(s),n.object.lookAt(n.target),!0===n.enableDamping?(l.theta*=1-n.dampingFactor,l.phi*=1-n.dampingFactor,h.multiplyScalar(1-n.dampingFactor)):(l.set(0,0,0),h.set(0,0,0));let v=!1;if(n.zoomToCursor&&I){let r=null;if(n.object.isPerspectiveCamera){const e=s.length();r=k(e*c);const t=e-r;n.object.position.addScaledVector(y,t),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const e=new t.Vector3(x.x,x.y,0);e.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/c)),n.object.updateProjectionMatrix(),v=!0;const i=new t.Vector3(x.x,x.y,0);i.unproject(n.object),n.object.position.sub(i).add(e),n.object.updateMatrixWorld(),r=s.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==r&&(this.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(r).add(n.object.position):(dt.origin.copy(n.object.position),dt.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(dt.direction))<ut?e.lookAt(n.target):(pt.setFromNormalAndCoplanarPoint(n.object.up,n.target),dt.intersectPlane(pt,n.target))))}else n.object.isOrthographicCamera&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/c)),n.object.updateProjectionMatrix(),v=!0);return c=1,I=!1,!!(v||u.distanceToSquared(n.object.position)>o||8*(1-A.dot(n.object.quaternion))>o||m.distanceToSquared(n.target)>0)&&(n.dispatchEvent(lt),u.copy(n.object.position),A.copy(n.object.quaternion),m.copy(n.target),v=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",q),n.domElement.removeEventListener("pointerdown",N),n.domElement.removeEventListener("pointercancel",K),n.domElement.removeEventListener("wheel",j),n.domElement.removeEventListener("pointermove",G),n.domElement.removeEventListener("pointerup",K),null!==n._domElementKeyEvents&&(n._domElementKeyEvents.removeEventListener("keydown",W),n._domElementKeyEvents=null)};const n=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=r.NONE;const o=1e-6,a=new t.Spherical,l=new t.Spherical;let c=1;const h=new t.Vector3,d=new t.Vector2,p=new t.Vector2,u=new t.Vector2,A=new t.Vector2,m=new t.Vector2,g=new t.Vector2,f=new t.Vector2,C=new t.Vector2,S=new t.Vector2,y=new t.Vector3,x=new t.Vector2;let I=!1;const v=[],B={};function w(){return Math.pow(.95,n.zoomSpeed)}function b(e){l.theta-=e}function E(e){l.phi-=e}const D=function(){const e=new t.Vector3;return function(t,s){e.setFromMatrixColumn(s,0),e.multiplyScalar(-t),h.add(e)}}(),T=function(){const e=new t.Vector3;return function(t,s){!0===n.screenSpacePanning?e.setFromMatrixColumn(s,1):(e.setFromMatrixColumn(s,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),h.add(e)}}(),M=function(){const e=new t.Vector3;return function(t,s){const r=n.domElement;if(n.object.isPerspectiveCamera){const i=n.object.position;e.copy(i).sub(n.target);let o=e.length();o*=Math.tan(n.object.fov/2*Math.PI/180),D(2*t*o/r.clientHeight,n.object.matrix),T(2*s*o/r.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(D(t*(n.object.right-n.object.left)/n.object.zoom/r.clientWidth,n.object.matrix),T(s*(n.object.top-n.object.bottom)/n.object.zoom/r.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function F(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?c/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function R(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?c*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function P(t){if(!n.zoomToCursor)return;I=!0;const s=n.domElement.getBoundingClientRect(),r=t.clientX-s.left,i=t.clientY-s.top,o=s.width,a=s.height;x.x=r/o*2-1,x.y=-i/a*2+1,y.set(x.x,x.y,1).unproject(e).sub(e.position).normalize()}function k(e){return Math.max(n.minDistance,Math.min(n.maxDistance,e))}function H(e){d.set(e.clientX,e.clientY)}function L(e){A.set(e.clientX,e.clientY)}function O(){if(1===v.length)d.set(v[0].pageX,v[0].pageY);else{const e=.5*(v[0].pageX+v[1].pageX),t=.5*(v[0].pageY+v[1].pageY);d.set(e,t)}}function _(){if(1===v.length)A.set(v[0].pageX,v[0].pageY);else{const e=.5*(v[0].pageX+v[1].pageX),t=.5*(v[0].pageY+v[1].pageY);A.set(e,t)}}function U(){const e=v[0].pageX-v[1].pageX,t=v[0].pageY-v[1].pageY,s=Math.sqrt(e*e+t*t);f.set(0,s)}function Q(e){if(1==v.length)p.set(e.pageX,e.pageY);else{const t=X(e),s=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);p.set(s,n)}u.subVectors(p,d).multiplyScalar(n.rotateSpeed);const t=n.domElement;b(2*Math.PI*u.x/t.clientHeight),E(2*Math.PI*u.y/t.clientHeight),d.copy(p)}function z(e){if(1===v.length)m.set(e.pageX,e.pageY);else{const t=X(e),s=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);m.set(s,n)}g.subVectors(m,A).multiplyScalar(n.panSpeed),M(g.x,g.y),A.copy(m)}function V(e){const t=X(e),s=e.pageX-t.x,r=e.pageY-t.y,i=Math.sqrt(s*s+r*r);C.set(0,i),S.set(0,Math.pow(C.y/f.y,n.zoomSpeed)),F(S.y),f.copy(C)}function N(e){!1!==n.enabled&&(0===v.length&&(n.domElement.setPointerCapture(e.pointerId),n.domElement.addEventListener("pointermove",G),n.domElement.addEventListener("pointerup",K)),function(e){v.push(e)}(e),"touch"===e.pointerType?function(e){switch(Y(e),v.length){case 1:switch(n.touches.ONE){case t.TOUCH.ROTATE:if(!1===n.enableRotate)return;O(),i=r.TOUCH_ROTATE;break;case t.TOUCH.PAN:if(!1===n.enablePan)return;_(),i=r.TOUCH_PAN;break;default:i=r.NONE}break;case 2:switch(n.touches.TWO){case t.TOUCH.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&U(),n.enablePan&&_(),i=r.TOUCH_DOLLY_PAN;break;case t.TOUCH.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&U(),n.enableRotate&&O(),i=r.TOUCH_DOLLY_ROTATE;break;default:i=r.NONE}break;default:i=r.NONE}i!==r.NONE&&n.dispatchEvent(ct)}(e):function(e){let s;switch(e.button){case 0:s=n.mouseButtons.LEFT;break;case 1:s=n.mouseButtons.MIDDLE;break;case 2:s=n.mouseButtons.RIGHT;break;default:s=-1}switch(s){case t.MOUSE.DOLLY:if(!1===n.enableZoom)return;!function(e){P(e),f.set(e.clientX,e.clientY)}(e),i=r.DOLLY;break;case t.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;L(e),i=r.PAN}else{if(!1===n.enableRotate)return;H(e),i=r.ROTATE}break;case t.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;H(e),i=r.ROTATE}else{if(!1===n.enablePan)return;L(e),i=r.PAN}break;default:i=r.NONE}i!==r.NONE&&n.dispatchEvent(ct)}(e))}function G(e){!1!==n.enabled&&("touch"===e.pointerType?function(e){switch(Y(e),i){case r.TOUCH_ROTATE:if(!1===n.enableRotate)return;Q(e),n.update();break;case r.TOUCH_PAN:if(!1===n.enablePan)return;z(e),n.update();break;case r.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(e){n.enableZoom&&V(e),n.enablePan&&z(e)}(e),n.update();break;case r.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(e){n.enableZoom&&V(e),n.enableRotate&&Q(e)}(e),n.update();break;default:i=r.NONE}}(e):function(e){switch(i){case r.ROTATE:if(!1===n.enableRotate)return;!function(e){p.set(e.clientX,e.clientY),u.subVectors(p,d).multiplyScalar(n.rotateSpeed);const t=n.domElement;b(2*Math.PI*u.x/t.clientHeight),E(2*Math.PI*u.y/t.clientHeight),d.copy(p),n.update()}(e);break;case r.DOLLY:if(!1===n.enableZoom)return;!function(e){C.set(e.clientX,e.clientY),S.subVectors(C,f),S.y>0?F(w()):S.y<0&&R(w()),f.copy(C),n.update()}(e);break;case r.PAN:if(!1===n.enablePan)return;!function(e){m.set(e.clientX,e.clientY),g.subVectors(m,A).multiplyScalar(n.panSpeed),M(g.x,g.y),A.copy(m),n.update()}(e)}}(e))}function K(e){!function(e){delete B[e.pointerId];for(let t=0;t<v.length;t++)if(v[t].pointerId==e.pointerId)return void v.splice(t,1)}(e),0===v.length&&(n.domElement.releasePointerCapture(e.pointerId),n.domElement.removeEventListener("pointermove",G),n.domElement.removeEventListener("pointerup",K)),n.dispatchEvent(ht),i=r.NONE}function j(e){!1!==n.enabled&&!1!==n.enableZoom&&i===r.NONE&&(e.preventDefault(),n.dispatchEvent(ct),function(e){P(e),e.deltaY<0?R(w()):e.deltaY>0&&F(w()),n.update()}(e),n.dispatchEvent(ht))}function W(e){!1!==n.enabled&&!1!==n.enablePan&&function(e){let t=!1;switch(e.code){case n.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?E(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):M(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?E(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):M(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?b(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):M(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?b(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):M(-n.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),n.update())}(e)}function q(e){!1!==n.enabled&&e.preventDefault()}function Y(e){let s=B[e.pointerId];void 0===s&&(s=new t.Vector2,B[e.pointerId]=s),s.set(e.pageX,e.pageY)}function X(e){const t=e.pointerId===v[0].pointerId?v[1]:v[0];return B[t.pointerId]}n.domElement.addEventListener("contextmenu",q),n.domElement.addEventListener("pointerdown",N),n.domElement.addEventListener("pointercancel",K),n.domElement.addEventListener("wheel",j,{passive:!1}),this.update()}}class mt{static elementIDGen=0;constructor(e,t){this.taskIDGen=0,this.elementID=mt.elementIDGen++,this.tasks=[],this.message=e||"Loading...",this.container=t||document.body,this.spinnerContainerOuter=document.createElement("div"),this.spinnerContainerOuter.className=`spinnerOuterContainer${this.elementID}`,this.spinnerContainerOuter.style.display="none",this.spinnerContainerPrimary=document.createElement("div"),this.spinnerContainerPrimary.className=`spinnerContainerPrimary${this.elementID}`,this.spinnerPrimary=document.createElement("div"),this.spinnerPrimary.classList.add(`spinner${this.elementID}`,`spinnerPrimary${this.elementID}`),this.messageContainerPrimary=document.createElement("div"),this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`,`messageContainerPrimary${this.elementID}`),this.messageContainerPrimary.innerHTML=this.message,this.spinnerContainerMin=document.createElement("div"),this.spinnerContainerMin.className=`spinnerContainerMin${this.elementID}`,this.spinnerMin=document.createElement("div"),this.spinnerMin.classList.add(`spinner${this.elementID}`,`spinnerMin${this.elementID}`),this.messageContainerMin=document.createElement("div"),this.messageContainerMin.classList.add(`messageContainer${this.elementID}`,`messageContainerMin${this.elementID}`),this.messageContainerMin.innerHTML=this.message,this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),this.spinnerContainerMin.appendChild(this.spinnerMin),this.spinnerContainerMin.appendChild(this.messageContainerMin),this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);const s=document.createElement("style");s.innerHTML=`\n\n            .spinnerOuterContainer${this.elementID} {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .messageContainer${this.elementID} {\n                height: 20px;\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                vertical-align: middle;\n            }\n\n            .spinner${this.elementID} {\n                padding: 15px;\n                background: #07e8d6;\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n            }\n\n            .spinnerContainerPrimary${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 10px;\n                margin: 0;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n                pointer-events: auto;\n            }\n\n            .spinnerPrimary${this.elementID} {\n                width: 120px;\n                margin-left: 30px;\n            }\n\n            .messageContainerPrimary${this.elementID} {\n                padding-top: 15px;\n            }\n\n            .spinnerContainerMin${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                display: flex;\n                flex-direction: left;\n                pointer-events: auto;\n                min-width: 250px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                margin-right: 15px;\n            }\n\n            .spinnerMin${this.elementID} {\n                width: 50px;\n                height: 50px;\n                margin-left: 15px;\n                margin-right: 25px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                padding-top: 15px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        `,this.spinnerContainerOuter.appendChild(s),this.container.appendChild(this.spinnerContainerOuter),this.setMinimized(!1,!0),this.fadeTransitions=[]}addTask(e){const t={message:e,id:this.taskIDGen++};return this.tasks.push(t),this.update(),t.id}removeTask(e){let t=0;for(let s of this.tasks){if(s.id===e){this.tasks.splice(t,1);break}t++}this.update()}removeAllTasks(){this.tasks=[],this.update()}setMessageForTask(e,t){for(let s of this.tasks)if(s.id===e){s.message=t;break}this.update()}update(){this.tasks.length>0?(this.show(),this.setMessage(this.tasks[this.tasks.length-1].message)):this.hide()}show(){this.spinnerContainerOuter.style.display="block",this.visible=!0}hide(){this.spinnerContainerOuter.style.display="none",this.visible=!1}setContainer(e){this.container&&this.container.removeChild(this.spinnerContainerOuter),e&&(this.container=e,this.container.appendChild(this.spinnerContainerOuter),this.spinnerContainerOuter.style.zIndex=this.container.style.zIndex+1)}setMinimized(e,t){const s=(e,t,s,n,r)=>{s?e.style.display=t?n:"none":this.fadeTransitions[r]=((e,t,s,n,r)=>{const i=performance.now();let o="none"===e.style.display?0:parseFloat(e.style.opacity);isNaN(o)&&(o=1);const a=window.setInterval((()=>{const l=performance.now()-i;let c,h=Math.min(l/n,1);h>.999&&(h=1),t?(c=(1-h)*o,c<1e-4&&(c=0)):c=(1-o)*h+o,c>0?(e.style.display=s,e.style.opacity=c):e.style.display="none",h>=1&&(r&&r(),window.clearInterval(a))}),16);return a})(e,!t,n,500,(()=>{this.fadeTransitions[r]=null}))};s(this.spinnerContainerPrimary,!e,t,"block",0),s(this.spinnerContainerMin,e,t,"flex",1),this.minimized=e}setMessage(e){this.messageContainerPrimary.innerHTML=e,this.messageContainerMin.innerHTML=e}}class gt{constructor(e){this.idGen=0,this.tasks=[],this.container=e||document.body,this.progressBarContainerOuter=document.createElement("div"),this.progressBarContainerOuter.className="progressBarOuterContainer",this.progressBarContainerOuter.style.display="none",this.progressBarBox=document.createElement("div"),this.progressBarBox.className="progressBarBox",this.progressBarBackground=document.createElement("div"),this.progressBarBackground.className="progressBarBackground",this.progressBar=document.createElement("div"),this.progressBar.className="progressBar",this.progressBarBackground.appendChild(this.progressBar),this.progressBarBox.appendChild(this.progressBarBackground),this.progressBarContainerOuter.appendChild(this.progressBarBox);const t=document.createElement("style");t.innerHTML="\n\n            .progressBarOuterContainer {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .progressBarBox {\n                z-index:99999;\n                padding: 7px 9px 5px 7px;\n                background-color: rgba(190, 190, 190, 0.75);\n                border: #555555 1px solid;\n                border-radius: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                width: 180px;\n                height: 30px;\n                pointer-events: auto;\n            }\n\n            .progressBarBackground {\n                width: 100%;\n                height: 25px;\n                border-radius:10px;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #444444 1px solid;\n                box-shadow: inset 0 0 10px #333333;\n            }\n\n            .progressBar {\n                height: 25px;\n                width: 0px;\n                border-radius:10px;\n                background-color: rgba(0, 200, 0, 0.75);\n                box-shadow: inset 0 0 10px #003300;\n            }\n\n        ",this.progressBarContainerOuter.appendChild(t),this.container.appendChild(this.progressBarContainerOuter)}show(){this.progressBarContainerOuter.style.display="block"}hide(){this.progressBarContainerOuter.style.display="none"}setProgress(e){this.progressBar.style.width=e+"%"}setContainer(e){this.container&&this.container.removeChild(this.progressBarContainerOuter),e&&(this.container=e,this.container.appendChild(this.progressBarContainerOuter),this.progressBarContainerOuter.style.zIndex=this.container.style.zIndex+1)}}class ft{constructor(e){this.container=e||document.body,this.infoCells={};const t=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Camera mode","orthographicCamera"],["Cursor position","cursorPosition"],["FPS","fps"],["Rendering:","renderSplatCount"],["Sort time","sortTime"],["Render window","renderWindow"],["Focal adjustment","focalAdjustment"],["Splat scale","splatScale"],["Point cloud mode","pointCloudMode"]];this.infoPanelContainer=document.createElement("div");const s=document.createElement("style");s.innerHTML="\n\n            .infoPanel {\n                width: 430px;\n                padding: 10px;\n                background-color: rgba(50, 50, 50, 0.85);\n                border: #555555 2px solid;\n                color: #dddddd;\n                border-radius: 10px;\n                z-index: 9999;\n                font-family: arial;\n                font-size: 11pt;\n                text-align: left;\n                margin: 0;\n                top: 10px;\n                left:10px;\n                position: absolute;\n                pointer-events: auto;\n            }\n\n            .info-panel-cell {\n                margin-bottom: 5px;\n                padding-bottom: 2px;\n            }\n\n            .label-cell {\n                font-weight: bold;\n                font-size: 12pt;\n                width: 140px;\n            }\n\n        ",this.infoPanelContainer.append(s),this.infoPanel=document.createElement("div"),this.infoPanel.className="infoPanel";const n=document.createElement("div");n.style.display="table";for(let e of t){const t=document.createElement("div");t.style.display="table-row",t.className="info-panel-row";const s=document.createElement("div");s.style.display="table-cell",s.innerHTML=`${e[0]}: `,s.classList.add("info-panel-cell","label-cell");const r=document.createElement("div");r.style.display="table-cell",r.style.width="10px",r.innerHTML=" ",r.className="info-panel-cell";const i=document.createElement("div");i.style.display="table-cell",i.innerHTML="",i.className="info-panel-cell",this.infoCells[e[1]]=i,t.appendChild(s),t.appendChild(r),t.appendChild(i),n.appendChild(t)}this.infoPanel.appendChild(n),this.infoPanelContainer.append(this.infoPanel),this.infoPanelContainer.style.display="none",this.container.appendChild(this.infoPanelContainer),this.visible=!1}update=function(e,t,s,n,r,i,o,a,l,c,h,d,p,u){const A=`${t.x.toFixed(5)}, ${t.y.toFixed(5)}, ${t.z.toFixed(5)}`;if(this.infoCells.cameraPosition.innerHTML!==A&&(this.infoCells.cameraPosition.innerHTML=A),s){const e=s,t=`${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}`;this.infoCells.cameraLookAt.innerHTML!==t&&(this.infoCells.cameraLookAt.innerHTML=t)}const m=`${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}`;if(this.infoCells.cameraUp.innerHTML!==m&&(this.infoCells.cameraUp.innerHTML=m),this.infoCells.orthographicCamera.innerHTML=r?"Orthographic":"Perspective",i){const e=i,t=`${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}`;this.infoCells.cursorPosition.innerHTML=t}else this.infoCells.cursorPosition.innerHTML="N/A";this.infoCells.fps.innerHTML=o,this.infoCells.renderWindow.innerHTML=`${e.x} x ${e.y}`,this.infoCells.renderSplatCount.innerHTML=`${l} splats out of ${a} (${c.toFixed(2)}%)`,this.infoCells.sortTime.innerHTML=`${h.toFixed(3)} ms`,this.infoCells.focalAdjustment.innerHTML=`${d.toFixed(3)}`,this.infoCells.splatScale.innerHTML=`${p.toFixed(3)}`,this.infoCells.pointCloudMode.innerHTML=`${u}`};setContainer(e){this.container&&this.container.removeChild(this.infoPanelContainer),e&&(this.container=e,this.container.appendChild(this.infoPanelContainer),this.infoPanelContainer.style.zIndex=this.container.style.zIndex+1)}show(){this.infoPanelContainer.style.display="block",this.visible=!0}hide(){this.infoPanelContainer.style.display="none",this.visible=!1}}class Ct extends n.Object3D{constructor(e=new n.Vector3(0,0,1),t=new n.Vector3(0,0,0),s=1,r=.1,i=16776960,o=.2*s,a=.2*o){super(),this.type="ArrowHelper";const l=new n.CylinderGeometry(r,r,s,32);l.translate(0,s/2,0);const c=new n.CylinderGeometry(0,a,o,32);c.translate(0,s,0),this.position.copy(t),this.line=new n.Mesh(l,new n.MeshBasicMaterial({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new n.Mesh(c,new n.MeshBasicMaterial({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(_axis,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class St{constructor(e){this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(e,t){this.destroySplatRendertarget(),this.splatRenderTarget=new n.WebGLRenderTarget(e,t,{format:n.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new n.DepthTexture(e,t),this.splatRenderTarget.depthTexture.format=n.DepthFormat,this.splatRenderTarget.depthTexture.type=n.UnsignedIntType}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const e=new n.ShaderMaterial({vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",uniforms:{sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},depthWrite:!1,depthTest:!1,transparent:!0,blending:n.CustomBlending,blendSrc:n.SrcAlphaFactor,blendSrcAlpha:n.SrcAlphaFactor,blendDst:n.OneMinusSrcAlphaFactor,blendDstAlpha:n.OneMinusSrcAlphaFactor});e.extensions.fragDepth=!0,this.renderTargetCopyQuad=new n.Mesh(new n.PlaneGeometry(2,2),e),this.renderTargetCopyCamera=new n.OrthographicCamera(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(h(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const e=new n.ConeGeometry(.5,1.5,32),t=new n.MeshBasicMaterial({color:16777215}),s=new n.Mesh(e,t);s.rotation.set(0,0,Math.PI),s.position.set(0,1,0);const r=new n.Mesh(e,t);r.position.set(0,-1,0);const i=new n.Mesh(e,t);i.rotation.set(0,0,Math.PI/2),i.position.set(1,0,0);const o=new n.Mesh(e,t);o.rotation.set(0,0,-Math.PI/2),o.position.set(-1,0,0),this.meshCursor=new n.Object3D,this.meshCursor.add(s),this.meshCursor.add(r),this.meshCursor.add(i),this.meshCursor.add(o),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(h(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}getMeschCursorVisibility(){return this.meshCursor.visible}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const e=new n.SphereGeometry(.5,32,32),t=St.buildFocusMarkerMaterial();t.depthTest=!1,t.depthWrite=!1,t.transparent=!0,this.focusMarker=new n.Mesh(e,t)}}destroyFocusMarker(){this.focusMarker&&(h(this.focusMarker),this.focusMarker=null)}updateFocusMarker=function(){const e=new n.Vector3,t=new n.Matrix4,s=new n.Vector3;return function(n,r,i){t.copy(r.matrixWorld).invert(),e.copy(n).applyMatrix4(t),e.normalize().multiplyScalar(10),e.applyMatrix4(r.matrixWorld),s.copy(r.position).sub(n);const o=s.length();this.focusMarker.position.copy(n),this.focusMarker.scale.set(o,o,o),this.focusMarker.material.uniforms.realFocusPosition.value.copy(n),this.focusMarker.material.uniforms.viewport.value.copy(i),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const e=new n.PlaneGeometry(1,1);e.rotateX(-Math.PI/2);const t=new n.MeshBasicMaterial({color:16777215});t.transparent=!0,t.opacity=.6,t.depthTest=!1,t.depthWrite=!1,t.side=n.DoubleSide;const s=new n.Mesh(e,t),r=new n.Vector3(0,1,0);r.normalize();const i=new n.Vector3(0,0,0),o=new Ct(r,i,.5,.01,56576,.1,.03);this.controlPlane=new n.Object3D,this.controlPlane.add(s),this.controlPlane.add(o)}}destroyControlPlane(){this.controlPlane&&(h(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const e=new n.Quaternion,t=new n.Vector3(0,1,0);return function(s,n){e.setFromUnitVectors(t,n),this.controlPlane.position.copy(s),this.controlPlane.quaternion.copy(e)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(h(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(e){const t=new n.SphereGeometry(1,32,32),s=new n.Object3D,r=(r,i)=>{let o=new n.Mesh(t,St.buildDebugMaterial(r));o.renderOrder=e,s.add(o),o.position.fromArray(i)};return r(16711680,[-50,0,0]),r(16711680,[50,0,0]),r(65280,[0,0,-50]),r(65280,[0,0,50]),r(16755200,[5,0,5]),s}createSecondaryDebugMeshes(e){const t=new n.BoxGeometry(3,3,3),s=new n.Object3D;const r=r=>{let i=new n.Mesh(t,St.buildDebugMaterial(12303291));i.renderOrder=e,s.add(i),i.position.fromArray(r)};let i=10;return r([-10,0,-10]),r([-10,0,i]),r([i,0,-10]),r([i,0,i]),s}static buildDebugMaterial(e){const t={color:{type:"v3",value:new n.Color(e)}},s=new n.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",transparent:!1,depthTest:!0,depthWrite:!0,side:n.FrontSide});return s.extensions.fragDepth=!0,s}static buildFocusMarkerMaterial(e){const t={color:{type:"v3",value:new n.Color(e)},realFocusPosition:{type:"v3",value:new n.Vector3},viewport:{type:"v2",value:new n.Vector2},opacity:{value:0}};return new n.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",transparent:!0,depthTest:!1,depthWrite:!1,side:n.FrontSide})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const yt=new n.Vector3(1,0,0),xt=new n.Vector3(0,1,0),It=new n.Vector3(0,0,1);class vt{constructor(e=new n.Vector3,t=new n.Vector3){this.origin=new n.Vector3,this.direction=new n.Vector3,this.setParameters(e,t)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,s){return!(t.x<e.min.x-s||t.x>e.max.x+s||t.y<e.min.y-s||t.y>e.max.y+s||t.z<e.min.z-s||t.z>e.max.z+s)}intersectBox=function(){const e=new n.Vector3,t=[],s=[],r=[];return function(n,i){if(s[0]=this.origin.x,s[1]=this.origin.y,s[2]=this.origin.z,r[0]=this.direction.x,r[1]=this.direction.y,r[2]=this.direction.z,this.boxContainsPoint(n,this.origin,1e-4))return i&&(i.origin.copy(this.origin),i.normal.set(0,0,0),i.distance=-1),!0;for(let o=0;o<3;o++){if(0==r[o])continue;const a=0==o?yt:1==o?xt:It,l=r[o]<0?n.max:n.min;let c=-Math.sign(r[o]);t[0]=0==o?l.x:1==o?l.y:l.z;let h=t[0]-s[o];if(h*c<0){const l=(o+1)%3,d=(o+2)%3;if(t[2]=r[l]/r[o]*h+s[l],t[1]=r[d]/r[o]*h+s[d],e.set(t[o],t[d],t[l]),this.boxContainsPoint(n,e,1e-4))return i&&(i.origin.copy(e),i.normal.copy(a).multiplyScalar(c),i.distance=e.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const e=new n.Vector3;return function(t,s,n){e.copy(t).sub(this.origin);const r=e.dot(this.direction),i=r*r,o=e.dot(e)-i,a=s*s;if(o>a)return!1;const l=Math.sqrt(a-o),c=r-l,h=r+l;if(h<0)return!1;let d=c<0?h:c;return n&&(n.origin.copy(this.origin).addScaledVector(this.direction,d),n.normal.copy(n.origin).sub(t).normalize(),n.distance=d),!0}}()}class Bt{constructor(){this.origin=new n.Vector3,this.normal=new n.Vector3,this.distance=0,this.splatIndex=0}set(e,t,s,n){this.origin.copy(e),this.normal.copy(t),this.distance=s,this.splatIndex=n}clone(){const e=new Bt;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}class wt{constructor(e,t,s=!1){this.ray=new vt(e,t),this.raycastAgainstTrueSplatEllipsoid=s}setFromCameraAndScreenPosition=function(){const e=new n.Vector2;return function(t,s,n){if(e.x=s.x/n.x*2-1,e.y=(n.y-s.y)/n.y*2-1,t.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t;else{if(!t.isOrthographicCamera)throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t}}}();intersectSplatMesh=function(){const e=new n.Matrix4,t=new n.Matrix4,s=new n.Matrix4,r=new vt,i=new n.Vector3;return function(n,o=[]){const a=n.getSplatTree();if(a){for(let l=0;l<a.subTrees.length;l++){const c=a.subTrees[l];t.copy(n.matrixWorld),n.dynamicMode&&(n.getSceneTransform(l,s),t.multiply(s)),e.copy(t).invert(),r.origin.copy(this.ray.origin).applyMatrix4(e),r.direction.copy(this.ray.origin).add(this.ray.direction),r.direction.applyMatrix4(e).sub(r.origin).normalize();const h=[];c.rootNode&&this.castRayAtSplatTreeNode(r,a,c.rootNode,h),h.forEach((e=>{e.origin.applyMatrix4(t),e.normal.applyMatrix4(t).normalize(),e.distance=i.copy(e.origin).sub(this.ray.origin).length()})),o.push(...h)}return o.sort(((e,t)=>e.distance>t.distance?1:-1)),o}}}();castRayAtSplatTreeNode=function(){const e=new n.Vector4,t=new n.Vector3,s=new n.Vector3,r=new n.Quaternion,i=new Bt,o=1e-7,a=new n.Vector3(0,0,0),l=new n.Matrix4,c=new n.Matrix4,h=new n.Matrix4,d=new n.Matrix4,p=new n.Matrix4,u=new vt;return function(n,A,m,g=[]){if(n.intersectBox(m.boundingBox)){if(m.data&&m.data.indexes&&m.data.indexes.length>0)for(let f=0;f<m.data.indexes.length;f++){const C=m.data.indexes[f],S=A.splatMesh.getSceneIndexForSplat(C);if(A.splatMesh.getScene(S).visible&&(A.splatMesh.getSplatColor(C,e),A.splatMesh.getSplatCenter(C,t),A.splatMesh.getSplatScaleAndRotation(C,s,r),!(s.x<=o||s.y<=o||s.z<=o)))if(this.raycastAgainstTrueSplatEllipsoid){c.makeScale(s.x,s.y,s.z),h.makeRotationFromQuaternion(r);const o=2*Math.log10(e.w);if(l.makeScale(o,o,o),p.copy(l).multiply(h).multiply(c),d.copy(p).invert(),u.origin.copy(n.origin).sub(t).applyMatrix4(d),u.direction.copy(n.origin).add(n.direction).sub(t),u.direction.applyMatrix4(d).sub(u.origin).normalize(),u.intersectSphere(a,1,i)){const e=i.clone();e.splatIndex=C,e.origin.applyMatrix4(p).add(t),g.push(e)}}else{const e=(s.x+s.y+s.z)/3;if(n.intersectSphere(t,e,i)){const e=i.clone();e.splatIndex=C,g.push(e)}}}if(m.children&&m.children.length>0)for(let e of m.children)this.castRayAtSplatTreeNode(n,A,e,g);return g}}}()}class bt{static build(e=!1,t=!1,s=!1,r=2048,i=1,o=!1,a=0){let l="\n            precision highp float;\n            #include <common>\n\n            attribute uint splatIndex;\n\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D centersColorsTexture;\n            uniform highp sampler2D sphericalHarmonicsTexture;\n            uniform highp sampler2D sphericalHarmonicsTextureR;\n            uniform highp sampler2D sphericalHarmonicsTextureG;\n            uniform highp sampler2D sphericalHarmonicsTextureB;";(t||e)&&(l+="\n                uniform highp usampler2D sceneIndexesTexture;\n                uniform vec2 sceneIndexesTextureSize;\n            "),t&&(l+=`\n                uniform float sceneOpacity[${S.MaxScenes}];\n                uniform int sceneVisibility[${S.MaxScenes}];\n            `),e&&(l+=`\n                uniform highp mat4 transforms[${S.MaxScenes}];\n            `),l+=`\n            uniform vec2 focal;\n            uniform float orthoZoom;\n            uniform int orthographicMode;\n            uniform int pointCloudModeEnabled;\n            uniform float inverseFocalAdjustment;\n            uniform vec2 viewport;\n            uniform vec2 basisViewport;\n            uniform vec2 covariancesTextureSize;\n            uniform vec2 centersColorsTextureSize;\n            uniform int sphericalHarmonicsDegree;\n            uniform vec2 sphericalHarmonicsTextureSize;\n            uniform int sphericalHarmonics8BitMode;\n            uniform int sphericalHarmonicsMultiTextureMode;\n            uniform float visibleRegionRadius;\n            uniform float visibleRegionFadeStartRadius;\n            uniform float firstRenderTime;\n            uniform float currentTime;\n            uniform int fadeInComplete;\n            uniform vec3 sceneCenter;\n            uniform float splatScale;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            const float sqrt8 = sqrt(8.0);\n            const float minAlpha = 1.0 / 255.0;\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            const float SH_C1 = 0.4886025119029199f;\n            const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);\n\n            const float SphericalHarmonics8BitCompressionRange = ${S.SphericalHarmonics8BitCompressionRange.toFixed(1)};\n            const float SphericalHarmonics8BitCompressionHalfRange = SphericalHarmonics8BitCompressionRange / 2.0;\n            const vec3 vec8BitSHShift = vec3(SphericalHarmonics8BitCompressionHalfRange);\n\n            void main () {\n\n                uint oddOffset = splatIndex & uint(0x00000001);\n                uint doubleOddOffset = oddOffset * uint(2);\n                bool isEven = oddOffset == uint(0);\n                uint nearestEvenIndex = splatIndex - oddOffset;\n                float fOddOffset = float(oddOffset);\n\n                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));`,(e||t)&&(l+="\n                    uint sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;\n                "),t&&(l+="\n                    float splatOpacityFromScene = sceneOpacity[sceneIndex];\n                    int sceneVisible = sceneVisibility[sceneIndex];\n                    if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {\n                        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                        return;\n                    }\n                "),l+=e?"\n                    mat4 transform = transforms[sceneIndex];\n                    mat4 transformModelViewMatrix = modelViewMatrix * transform;\n                ":"mat4 transformModelViewMatrix = modelViewMatrix;",l+="\n                vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);\n\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                float clip = 1.2 * clipCenter.w;\n                if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n\n                vPosition = position.xy;\n                vColor = uintToRGBAVec(sampledCenterColor.r);\n            ",a>=1&&(l+="   \n                if (sphericalHarmonicsDegree >= 1) {\n                ",l+=e?"\n                        mat4 mTransform = modelMatrix * transform;\n                        vec3 worldViewDir = normalize(splatCenter - vec3(inverse(mTransform) * vec4(cameraPosition, 1.0)));\n                    ":"\n                        vec3 worldViewDir = normalize(splatCenter - cameraPosition);\n                    ",l+="\n                    vec3 sh1;\n                    vec3 sh2;\n                    vec3 sh3;\n                ",l+=a>=2?"\n                        vec4 sampledSH0123;\n                        vec4 sampledSH4567;\n                        vec4 sampledSH891011;\n\n                        vec4 sampledSH0123R;\n                        vec4 sampledSH0123G;\n                        vec4 sampledSH0123B;\n                        \n                        if (sphericalHarmonicsMultiTextureMode == 0) {\n                            sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));\n                            sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));\n                            sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));\n                            sh1 = sampledSH0123.rgb;\n                            sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);\n                            sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);\n                        } else {\n                            sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                            sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                            sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                            sh1 = vec3(sampledSH0123R.rgb);\n                            sh2 = vec3(sampledSH0123G.rgb);\n                            sh3 = vec3(sampledSH0123B.rgb);\n                        }\n                    ":"\n                        if (sphericalHarmonicsMultiTextureMode == 0) {\n                            vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);\n                            vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);\n                            shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);\n                            vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);\n                            shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);\n                            vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);\n                            sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;\n                            sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;\n                            sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;\n                        } else {\n                            vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                            vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                            vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                            vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                            vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                            vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                            sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);\n                            sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);\n                            sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);\n                        }\n                    ",l+="\n                        if (sphericalHarmonics8BitMode == 1) {\n                            sh1 = sh1 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                            sh2 = sh2 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                            sh3 = sh3 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                        }\n                        float x = worldViewDir.x;\n                        float y = worldViewDir.y;\n                        float z = worldViewDir.z;\n                        vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);\n                ",a>=2&&(l+="\n                        if (sphericalHarmonicsDegree >= 2) {\n                            float xx = x * x;\n                            float yy = y * y;\n                            float zz = z * z;\n                            float xy = x * y;\n                            float yz = y * z;\n                            float xz = x * z;\n\n                            vec3 sh4;\n                            vec3 sh5;\n                            vec3 sh6;\n                            vec3 sh7;\n                            vec3 sh8;\n\n                            if (sphericalHarmonicsMultiTextureMode == 0) {\n                                vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));\n                                vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));\n                                vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));\n                                sh4 = sampledSH891011.gba;\n                                sh5 = sampledSH12131415.rgb;\n                                sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);\n                                sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);\n                                sh8 = sampledSH20212223.gba;\n                            } else {\n                                vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                                vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                                vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                                sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);\n                                sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);\n                                sh6 = vec3(sampledSH4567G.rgb);\n                                sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);\n                                sh8 = vec3(sampledSH4567B.gba);\n                            }\n\n                            if (sphericalHarmonics8BitMode == 1) {\n                                sh4 = sh4 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                                sh5 = sh5 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                                sh6 = sh6 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                                sh7 = sh7 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                                sh8 = sh8 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;\n                            }\n\n                            vColor.rgb +=\n                                (SH_C2[0] * xy) * sh4 +\n                                (SH_C2[1] * yz) * sh5 +\n                                (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +\n                                (SH_C2[3] * xz) * sh7 +\n                                (SH_C2[4] * (xx - yy)) * sh8;\n                        }\n                    "),l+="\n               \n                    vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));\n\n                }\n\n                "),l+="\n\n                vec4 sampledCovarianceA = texture(covariancesTexture,\n                                                  getDataUVF(nearestEvenIndex, 1.5, oddOffset, covariancesTextureSize));\n                vec4 sampledCovarianceB = texture(covariancesTexture,\n                                                  getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1), covariancesTextureSize));\n\n                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +\n                                         vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;\n                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +\n                                         vec3(sampledCovarianceB.gba) * fOddOffset;\n\n                // Construct the 3D covariance matrix\n                mat3 Vrk = mat3(\n                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n                );\n\n                mat3 J;\n                if (orthographicMode == 1) {\n                    // Since the projection is linear, we don't need an approximation\n                    J = transpose(mat3(orthoZoom, 0.0, 0.0,\n                                       0.0, orthoZoom, 0.0,\n                                       0.0, 0.0, 0.0));\n                } else {\n                    // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the\n                    // 3D covariance matrix instead of using the actual projection matrix because that transformation would\n                    // require a non-linear component (perspective division) which would yield a non-gaussian result.\n                    float s = 1.0 / (viewCenter.z * viewCenter.z);\n                    J = mat3(\n                        focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                        0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                        0., 0., 0.\n                    );\n                }\n\n                // Concatenate the projection approximation with the model-view transformation\n                mat3 W = transpose(mat3(transformModelViewMatrix));\n                mat3 T = W * J;\n\n                // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix\n                mat3 cov2Dm = transpose(T) * Vrk * T;\n                ",l+=s?"\n                    float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                    cov2Dm[0][0] += 0.3;\n                    cov2Dm[1][1] += 0.3;\n                    float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                    vColor.a *= sqrt(max(detOrig / detBlur, 0.0));\n                    if (vColor.a < minAlpha) return;\n                ":"\n                    cov2Dm[0][0] += 0.3;\n                    cov2Dm[1][1] += 0.3;\n                ",l+=`\n\n                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n                // need cov2Dm[1][0] because it is a symetric matrix.\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n                // so that we can determine the 2D basis for the splat. This is done using the method described\n                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n                // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat\n                // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is\n                // equal to scaling them by sqrt(8) standard deviations.\n                //\n                // This is a different approach than in the original work at INRIA. In that work they compute the\n                // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle\n                // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0\n                // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse\n                // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by\n                // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = traceOver2 - term2;\n\n                if (pointCloudModeEnabled == 1) {\n                    eigenValue1 = eigenValue2 = 0.2;\n                }\n\n                if (eigenValue2 <= 0.0) return;\n\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                // since the eigen vectors are orthogonal, we derive the second one from the first\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n\n                // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\n                vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(r)}.0);\n                vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(r)}.0);\n\n                if (fadeInComplete == 0) {\n                    float opacityAdjust = 1.0;\n                    float centerDist = length(splatCenter - sceneCenter);\n                    float renderTime = max(currentTime - firstRenderTime, 0.0);\n\n                    float fadeDistance = 0.75;\n                    float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);\n                    distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +\n                                               (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *\n                                               distanceLoadFadeInFactor;\n                    opacityAdjust *= distanceLoadFadeInFactor;\n                    vColor.a *= opacityAdjust;\n                }\n                `,t&&(l+="\n                     vColor.a *= splatOpacityFromScene;\n                "),l+="\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *\n                                 basisViewport * 2.0 * inverseFocalAdjustment;\n\n                vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n                gl_Position = quadPos;\n\n                // Scale the position data we send to the fragment shader\n                vPosition *= sqrt8;\n            }";const c={sceneCenter:{type:"v3",value:new n.Vector3},fadeInComplete:{type:"i",value:0},orthographicMode:{type:"i",value:0},visibleRegionFadeStartRadius:{type:"f",value:0},visibleRegionRadius:{type:"f",value:0},currentTime:{type:"f",value:0},firstRenderTime:{type:"f",value:0},covariancesTexture:{type:"t",value:null},centersColorsTexture:{type:"t",value:null},sphericalHarmonicsTexture:{type:"t",value:null},sphericalHarmonicsTextureR:{type:"t",value:null},sphericalHarmonicsTextureG:{type:"t",value:null},sphericalHarmonicsTextureB:{type:"t",value:null},focal:{type:"v2",value:new n.Vector2},orthoZoom:{type:"f",value:1},inverseFocalAdjustment:{type:"f",value:1},viewport:{type:"v2",value:new n.Vector2},basisViewport:{type:"v2",value:new n.Vector2},debugColor:{type:"v3",value:new n.Color},covariancesTextureSize:{type:"v2",value:new n.Vector2(1024,1024)},centersColorsTextureSize:{type:"v2",value:new n.Vector2(1024,1024)},sphericalHarmonicsDegree:{type:"i",value:a},sphericalHarmonicsTextureSize:{type:"v2",value:new n.Vector2(1024,1024)},sphericalHarmonics8BitMode:{type:"i",value:0},sphericalHarmonicsMultiTextureMode:{type:"i",value:0},splatScale:{type:"f",value:i},pointCloudModeEnabled:{type:"i",value:o?1:0}};if((e||t)&&(c.sceneIndexesTexture={type:"t",value:null},c.sceneIndexesTextureSize={type:"v2",value:new n.Vector2(1024,1024)}),t){const e=[];for(let t=0;t<S.MaxScenes;t++)e.push(1);c.sceneOpacity={type:"f",value:e};const t=[];for(let e=0;e<S.MaxScenes;e++)t.push(1);c.sceneVisibility={type:"i",value:t}}if(e){const e=[];for(let t=0;t<S.MaxScenes;t++)e.push(new n.Matrix4);c.transforms={type:"mat4",value:e}}return new n.ShaderMaterial({uniforms:c,vertexShader:l,fragmentShader:"\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n                if (A > 8.0) discard;\n                vec3 color = vColor.rgb;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp(-0.5 * A) * vColor.a;\n\n                gl_FragColor = vec4(color.rgb, opacity);\n            }",transparent:!0,alphaTest:1,blending:n.NormalBlending,depthTest:!0,depthWrite:!1,side:n.DoubleSide})}}class Et{static build(e){const t=new n.BufferGeometry;t.setIndex([0,1,2,0,2,3]);const s=new Float32Array(12),r=new n.BufferAttribute(s,3);t.setAttribute("position",r),r.setXYZ(0,-1,-1,0),r.setXYZ(1,-1,1,0),r.setXYZ(2,1,1,0),r.setXYZ(3,1,-1,0),r.needsUpdate=!0;const i=(new n.InstancedBufferGeometry).copy(t),o=new Uint32Array(e),a=new n.InstancedBufferAttribute(o,1,!1);return a.setUsage(n.DynamicDrawUsage),i.setAttribute("splatIndex",a),i.instanceCount=0,i}}class Dt{constructor(e,t=new n.Vector3,s=new n.Quaternion,r=new n.Vector3(1,1,1),i=1,o=1,a=!0){this.splatBuffer=e,this.position=t.clone(),this.quaternion=s.clone(),this.scale=r.clone(),this.transform=new n.Matrix4,this.minimumAlpha=i,this.opacity=o,this.visible=a,this.updateTransform()}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(){this.transform.compose(this.position,this.quaternion,this.scale)}}class Tt{static idGen=0;constructor(e,t,s,r){this.min=(new n.Vector3).copy(e),this.max=(new n.Vector3).copy(t),this.boundingBox=new n.Box3(this.min,this.max),this.center=(new n.Vector3).copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=s,this.children=[],this.data=null,this.id=r||Tt.idGen++}}class Mt{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.sceneDimensions=new n.Vector3,this.sceneMin=new n.Vector3,this.sceneMax=new n.Vector3,this.rootNode=null,this.nodesWithIndexes=[],this.splatMesh=null}static convertWorkerSubTreeNode(e){const t=(new n.Vector3).fromArray(e.min),s=(new n.Vector3).fromArray(e.max),r=new Tt(t,s,e.depth,e.id);if(e.data.indexes){r.data={indexes:[]};for(let t of e.data.indexes)r.data.indexes.push(t)}if(e.children)for(let t of e.children)r.children.push(Mt.convertWorkerSubTreeNode(t));return r}static convertWorkerSubTree(e,t){const s=new Mt(e.maxDepth,e.maxCentersPerNode);s.sceneMin=(new n.Vector3).fromArray(e.sceneMin),s.sceneMax=(new n.Vector3).fromArray(e.sceneMax),s.splatMesh=t,s.rootNode=Mt.convertWorkerSubTreeNode(e.rootNode);const r=(e,t)=>{0===e.children.length&&t(e);for(let s of e.children)r(s,t)};return s.nodesWithIndexes=[],r(s.rootNode,(e=>{e.data&&e.data.indexes&&e.data.indexes.length>0&&s.nodesWithIndexes.push(e)})),s}}function Ft(e){let t=0;class s{constructor(e,t){this.min=[e[0],e[1],e[2]],this.max=[t[0],t[1],t[2]]}containsPoint(e){return e[0]>=this.min[0]&&e[0]<=this.max[0]&&e[1]>=this.min[1]&&e[1]<=this.max[1]&&e[2]>=this.min[2]&&e[2]<=this.max[2]}}class n{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.sceneDimensions=[],this.sceneMin=[],this.sceneMax=[],this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.splatMesh=null,this.disposed=!1}}class r{constructor(e,s,n,r){this.min=[e[0],e[1],e[2]],this.max=[s[0],s[1],s[2]],this.center=[.5*(s[0]-e[0])+e[0],.5*(s[1]-e[1])+e[1],.5*(s[2]-e[2])+e[2]],this.depth=n,this.children=[],this.data=null,this.id=r||t++}}processSplatTreeNode=function(e,t,n,i){const o=t.data.indexes.length;if(o<e.maxCentersPerNode||t.depth>e.maxDepth){const s=[];for(let n=0;n<t.data.indexes.length;n++)e.addedIndexes[t.data.indexes[n]]||(s.push(t.data.indexes[n]),e.addedIndexes[t.data.indexes[n]]=!0);return t.data.indexes=s,t.data.indexes.sort(((e,t)=>e>t?1:-1)),void e.nodesWithIndexes.push(t)}const a=[t.max[0]-t.min[0],t.max[1]-t.min[1],t.max[2]-t.min[2]],l=[.5*a[0],.5*a[1],.5*a[2]],c=[t.min[0]+l[0],t.min[1]+l[1],t.min[2]+l[2]],h=[new s([c[0]-l[0],c[1],c[2]-l[2]],[c[0],c[1]+l[1],c[2]]),new s([c[0],c[1],c[2]-l[2]],[c[0]+l[0],c[1]+l[1],c[2]]),new s([c[0],c[1],c[2]],[c[0]+l[0],c[1]+l[1],c[2]+l[2]]),new s([c[0]-l[0],c[1],c[2]],[c[0],c[1]+l[1],c[2]+l[2]]),new s([c[0]-l[0],c[1]-l[1],c[2]-l[2]],[c[0],c[1],c[2]]),new s([c[0],c[1]-l[1],c[2]-l[2]],[c[0]+l[0],c[1],c[2]]),new s([c[0],c[1]-l[1],c[2]],[c[0]+l[0],c[1],c[2]+l[2]]),new s([c[0]-l[0],c[1]-l[1],c[2]],[c[0],c[1],c[2]+l[2]])],d=[],p=[];for(let e=0;e<h.length;e++)d[e]=0,p[e]=[];const u=[0,0,0];for(let e=0;e<o;e++){const s=t.data.indexes[e],r=n[s];u[0]=i[r],u[1]=i[r+1],u[2]=i[r+2];for(let e=0;e<h.length;e++)h[e].containsPoint(u)&&(d[e]++,p[e].push(s))}for(let e=0;e<h.length;e++){const s=new r(h[e].min,h[e].max,t.depth+1);s.data={indexes:p[e]},t.children.push(s)}t.data={};for(let s of t.children)processSplatTreeNode(e,s,n,i)};const i=(e,t,s)=>{const i=[0,0,0],o=[0,0,0],a=[],l=Math.floor(e.length/4);for(let t=0;t<l;t++){const s=4*t,n=e[s],r=e[s+1],l=e[s+2],c=Math.round(e[s+3]);(0===t||n<i[0])&&(i[0]=n),(0===t||n>o[0])&&(o[0]=n),(0===t||r<i[1])&&(i[1]=r),(0===t||r>o[1])&&(o[1]=r),(0===t||l<i[2])&&(i[2]=l),(0===t||l>o[2])&&(o[2]=l),a.push(c)}const c=new n(t,s);return c.sceneMin=i,c.sceneMax=o,c.rootNode=new r(c.sceneMin,c.sceneMax,0),c.rootNode.data={indexes:a},c};e.onmessage=t=>{t.data.process&&function(t,s,n){const r=[];for(let e of t){const t=Math.floor(e.length/4);for(let s=0;s<t;s++){const t=4*s;r[Math.round(e[t+3])]=t}}const o=[];for(let e of t){const t=i(e,s,n);o.push(t),processSplatTreeNode(t,t.rootNode,r,e)}e.postMessage({subTrees:o})}(t.data.process.centers,t.data.process.maxDepth,t.data.process.maxCentersPerNode)}}class Rt{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.subTrees=[],this.splatMesh=null}dispose(){this.diposeSplatTreeWorker(),this.disposed=!0}diposeSplatTreeWorker(){this.splatTreeWorker&&this.splatTreeWorker.terminate(),this.splatTreeWorker=null}processSplatMesh=function(e,t=(()=>!0),s,r){this.splatTreeWorker||(this.splatTreeWorker=new Worker(URL.createObjectURL(new Blob(["(",Ft.toString(),")(self)"],{type:"application/javascript"})))),this.splatMesh=e,this.subTrees=[];const i=new n.Vector3,o=(s,n)=>{const r=new Float32Array(4*n);let o=0;for(let a=0;a<n;a++){const n=a+s;if(t(n)){e.getSplatCenter(n,i);const t=4*o;r[t]=i.x,r[t+1]=i.y,r[t+2]=i.z,r[t+3]=n,o++}}return r};return new Promise((t=>{const n=()=>!!this.disposed&&(this.diposeSplatTreeWorker(),t(),!0);s&&s(!1),d((()=>{if(n())return;const i=[];if(e.dynamicMode){let t=0;for(let s=0;s<e.scenes.length;s++){const n=e.getScene(s).splatBuffer.getSplatCount(),r=o(t,n);i.push(r),t+=n}}else{const t=o(0,e.getSplatCount());i.push(t)}this.splatTreeWorker.onmessage=s=>{n()||s.data.subTrees&&(r&&r(!1),d((()=>{if(!n()){for(let t of s.data.subTrees){const s=Mt.convertWorkerSubTree(t,e);this.subTrees.push(s)}this.diposeSplatTreeWorker(),r&&r(!0),d((()=>{t()}))}})))},d((()=>{if(n())return;s&&s(!0);const e=i.map((e=>e.buffer));!function(e,t,s,n,r){e.postMessage({process:{centers:t,maxDepth:n,maxCentersPerNode:r}},s)}(this.splatTreeWorker,i,e,this.maxDepth,this.maxCentersPerNode)}))}))}))};countLeaves(){let e=0;return this.visitLeaves((()=>{e++})),e}visitLeaves(e){const t=(e,s)=>{0===e.children.length&&s(e);for(let n of e.children)t(n,s)};for(let s of this.subTrees)t(s.rootNode,e)}}function Pt(e){const t={};function s(s){if(void 0!==t[s])return t[s];let n;switch(s){case"WEBGL_depth_texture":n=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=e.getExtension(s)}return t[s]=n,n}return{has:function(e){return null!==s(e)},init:function(e){e.isWebGL2?(s("EXT_color_buffer_float"),s("WEBGL_clip_cull_distance")):(s("WEBGL_depth_texture"),s("OES_texture_float"),s("OES_texture_half_float"),s("OES_texture_half_float_linear"),s("OES_standard_derivatives"),s("OES_element_index_uint"),s("OES_vertex_array_object"),s("ANGLE_instanced_arrays")),s("OES_texture_float_linear"),s("EXT_color_buffer_half_float"),s("WEBGL_multisampled_render_to_texture")},get:function(e){const t=s(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function kt(e,t,s){let n;function r(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const i="undefined"!=typeof WebGL2RenderingContext&&"WebGL2RenderingContext"===e.constructor.name;let o=void 0!==s.precision?s.precision:"highp";const a=r(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=i||t.has("WEBGL_draw_buffers"),c=!0===s.logarithmicDepthBuffer,h=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),d=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=e.getParameter(e.MAX_TEXTURE_SIZE),u=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),A=e.getParameter(e.MAX_VERTEX_ATTRIBS),m=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),g=e.getParameter(e.MAX_VARYING_VECTORS),f=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),C=d>0,S=i||t.has("OES_texture_float");return{isWebGL2:i,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==n)return n;if(!0===t.has("EXT_texture_filter_anisotropic")){const s=t.get("EXT_texture_filter_anisotropic");n=e.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n},getMaxPrecision:r,precision:o,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:u,maxAttributes:A,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:f,vertexTextures:C,floatFragmentTextures:S,floatVertexTextures:C&&S,maxSamples:i?e.getParameter(e.MAX_SAMPLES):0}}const Ht={Default:0,Gradual:1,Instant:2},Lt={None:0,Error:1,Warning:2,Info:3,Debug:4},Ot=new n.BufferGeometry,_t=new n.MeshBasicMaterial;class Ut extends n.Mesh{constructor(e=!0,t=!1,s=!1,r=1,i=!0,o=!1,a=!1,l=1024,c=Lt.None,h=0){super(Ot,_t),this.renderer=void 0,this.halfPrecisionCovariancesOnGPU=s,this.dynamicMode=e,this.devicePixelRatio=r,this.enableDistancesComputationOnGPU=i,this.integerBasedDistancesComputation=o,this.antialiased=a,this.maxScreenSpaceSplatSize=l,this.logLevel=c,this.sphericalHarmonicsDegree=h,this.minSphericalHarmonicsDegree=0,this.enableOptionalEffects=t,this.scenes=[],this.splatTree=null,this.baseSplatTree=null,this.splatDataTextures={},this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new n.Box3,this.calculatedSceneCenter=new n.Vector3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!1,this.lastRenderer=null,this.visible=!1}static buildScenes(e,t){const s=[];s.length=e.length;for(let r=0;r<e.length;r++){const i=e[r],o=t[r]||{};let a=o.position||[0,0,0],l=o.rotation||[0,0,0,1],c=o.scale||[1,1,1];const h=(new n.Vector3).fromArray(a),d=(new n.Quaternion).fromArray(l),p=(new n.Vector3).fromArray(c);s[r]=Ut.createScene(i,h,d,p,o.splatAlphaRemovalThreshold||1)}return s}static createScene(e,t,s,n,r){return new Dt(e,t,s,n,r)}static buildSplatIndexMaps(e){const t=[],s=[];let n=0;for(let r=0;r<e.length;r++){const i=e[r].getMaxSplatCount();for(let e=0;e<i;e++)t[n]=e,s[n]=r,n++}return{localSplatIndexMap:t,sceneIndexMap:s}}buildSplatTree=function(e=[],t,s){return new Promise((r=>{this.disposeSplatTree(),this.baseSplatTree=new Rt(8,1e3);const i=performance.now(),o=new n.Vector4;this.baseSplatTree.processSplatMesh(this,(t=>{this.getSplatColor(t,o);const s=this.getSceneIndexForSplat(t),n=e[s]||1;return o.w>=n}),t,s).then((()=>{const e=performance.now()-i;if(this.logLevel>=Lt.Info&&console.log("SplatTree build: "+e+" ms"),this.disposed)r();else{this.splatTree=this.baseSplatTree,this.baseSplatTree=null;let e=0,t=0,s=0,n=0;this.splatTree.visitLeaves((r=>{const i=r.data.indexes.length;i>0&&(t+=i,s=Math.max(s,i),n++,e++)})),this.logLevel>=Lt.Info&&(console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${e}`),t/=n,console.log(`Avg splat count per node: ${t}`),console.log(`Total splat count: ${this.getSplatCount()}`)),r()}}))}))};build(e,t,s=!0,r=!1,i,o,a=!0){this.sceneOptions=t,this.finalBuild=r;const l=Ut.getTotalMaxSplatCountForSplatBuffers(e),c=Ut.buildScenes(e,t);if(s)for(let e=0;e<this.scenes.length&&e<c.length;e++){const t=c[e],s=this.getScene(e);t.copyTransformData(s)}this.scenes=c;let h=3;for(let t of e){const e=t.getMinSphericalHarmonicsDegree();e<h&&(h=e)}this.minSphericalHarmonicsDegree=Math.min(h,this.sphericalHarmonicsDegree);let d=!1;if(e.length!==this.lastBuildScenes.length)d=!0;else for(let t=0;t<e.length;t++){if(e[t]!==this.lastBuildScenes[t].splatBuffer){d=!0;break}}let p=!0;if((1!==this.scenes.length||this.lastBuildSceneCount!==this.scenes.length||this.lastBuildMaxSplatCount!==l||d)&&(p=!1),!p){this.boundingBox=new n.Box3,a||(this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.firstRenderTime=-1),this.lastBuildScenes=[],this.lastBuildSplatCount=0,this.lastBuildMaxSplatCount=0,this.disposeMeshData(),this.geometry=Et.build(l),this.material=bt.build(this.dynamicMode,this.enableOptionalEffects,this.antialiased,this.maxScreenSpaceSplatSize,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree);const t=Ut.buildSplatIndexMaps(e);this.globalSplatIndexToLocalSplatIndexMap=t.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=t.sceneIndexMap}const u=this.getSplatCount();this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback();const A=this.refreshGPUDataFromSplatBuffers(p);for(let e=0;e<this.scenes.length;e++)this.lastBuildScenes[e]=this.scenes[e];return this.lastBuildSplatCount=u,this.lastBuildMaxSplatCount=this.getMaxSplatCount(),this.lastBuildSceneCount=this.scenes.length,r&&this.scenes.length>0&&this.buildSplatTree(t.map((e=>e.splatAlphaRemovalThreshold||1)),i,o).then((()=>{this.onSplatTreeReadyCallback&&this.onSplatTreeReadyCallback(this.splatTree)})),this.visible=this.scenes.length>0,A}freeIntermediateSplatData(){const e=e=>{delete e.source.data,delete e.image,e.onUpdate=null};delete this.splatDataTextures.baseData.covariances,delete this.splatDataTextures.baseData.centers,delete this.splatDataTextures.baseData.colors,delete this.splatDataTextures.baseData.sphericalHarmonics,delete this.splatDataTextures.centerColors.data,delete this.splatDataTextures.covariances.data,this.splatDataTextures.sphericalHarmonics&&delete this.splatDataTextures.sphericalHarmonics.data,this.splatDataTextures.sceneIndexes&&delete this.splatDataTextures.sceneIndexes.data,this.splatDataTextures.centerColors.texture.needsUpdate=!0,this.splatDataTextures.centerColors.texture.onUpdate=()=>{e(this.splatDataTextures.centerColors.texture)},this.splatDataTextures.covariances.texture.needsUpdate=!0,this.splatDataTextures.covariances.texture.onUpdate=()=>{e(this.splatDataTextures.covariances.texture)},this.splatDataTextures.sphericalHarmonics&&(this.splatDataTextures.sphericalHarmonics.texture?(this.splatDataTextures.sphericalHarmonics.texture.needsUpdate=!0,this.splatDataTextures.sphericalHarmonics.texture.onUpdate=()=>{e(this.splatDataTextures.sphericalHarmonics.texture)}):this.splatDataTextures.sphericalHarmonics.textures.forEach((t=>{t.needsUpdate=!0,t.onUpdate=()=>{e(t)}}))),this.splatDataTextures.sceneIndexes&&(this.splatDataTextures.sceneIndexes.texture.needsUpdate=!0,this.splatDataTextures.sceneIndexes.texture.onUpdate=()=>{e(this.splatDataTextures.sceneIndexes.texture)})}dispose(){this.disposeMeshData(),this.disposeTextures(),this.disposeSplatTree(),this.enableDistancesComputationOnGPU&&(this.computeDistancesOnGPUSyncTimeout&&(clearTimeout(this.computeDistancesOnGPUSyncTimeout),this.computeDistancesOnGPUSyncTimeout=null),this.disposeDistancesComputationGPUResources()),this.scenes=[],this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.renderer=null,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new n.Box3,this.calculatedSceneCenter=new n.Vector3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!0,this.lastRenderer=null,this.visible=!1}disposeMeshData(){this.geometry&&this.geometry!==Ot&&(this.geometry.dispose(),this.geometry=null),this.material&&(this.material.dispose(),this.material=null)}disposeTextures(){for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const t=this.splatDataTextures[e];t.texture&&(t.texture.dispose(),t.texture=null)}this.splatDataTextures=null}disposeSplatTree(){this.splatTree?(this.splatTree.dispose(),this.splatTree=null):this.baseSplatTree&&(this.baseSplatTree.dispose(),this.baseSplatTree=null)}getSplatTree(){return this.splatTree}onSplatTreeReady(e){this.onSplatTreeReadyCallback=e}getDataForDistancesComputation(e,t){return{centers:this.integerBasedDistancesComputation?this.getIntegerCenters(e,t,!0):this.getFloatCenters(e,t,!0),sceneIndexes:this.getSceneIndexes(e,t)}}refreshGPUDataFromSplatBuffers(e){const t=this.getSplatCount();this.refreshDataTexturesFromSplatBuffers(e);const s=e?this.lastBuildSplatCount:0,{centers:n,sceneIndexes:r}=this.getDataForDistancesComputation(s,t-1);return this.enableDistancesComputationOnGPU&&this.refreshGPUBuffersForDistancesComputation(n,r,e),{from:s,to:t-1,count:t-s,centers:n,sceneIndexes:r}}refreshGPUBuffersForDistancesComputation(e,t,s=!1){const n=s?this.lastBuildSplatCount:0;this.updateGPUCentersBufferForDistancesComputation(s,e,n),this.updateGPUTransformIndexesBufferForDistancesComputation(s,t,n)}refreshDataTexturesFromSplatBuffers(e){if(e){const e=this.getSplatCount(),t=this.lastBuildSplatCount,s=e-1;this.updateBaseDataFromSplatBuffers(t,s),this.updateDataTexturesFromBaseData(t,s)}else this.setupDataTextures();this.updateVisibleRegion(e)}setupDataTextures(){const e=this.getMaxSplatCount(),t=this.getSplatCount();this.disposeTextures();const s=(t,s)=>{const r=new n.Vector2(4096,1024);for(;r.x*r.y*t<e*s;)r.y*=2;return r},r=this.getTargetCovarianceCompressionLevel(),i=this.getTargetSphericalHarmonicsCompressionLevel(),o=new Float32Array(6*e),a=new Float32Array(3*e),l=new Uint8Array(4*e);let c=Float32Array;1===i?c=Uint16Array:2===i&&(c=Uint8Array);const h=p(this.minSphericalHarmonicsDegree),d=this.minSphericalHarmonicsDegree?new c(e*h):void 0;this.fillSplatDataArrays(o,a,l,d,void 0,r,i);const u=s(4,6);let A=r>=1?Uint16Array:Float32Array,m=r>=1?n.HalfFloatType:n.FloatType;const g=new A(u.x*u.y*4);g.set(o);const f=new n.DataTexture(g,u.x,u.y,n.RGBAFormat,m);f.needsUpdate=!0,this.material.uniforms.covariancesTexture.value=f,this.material.uniforms.covariancesTextureSize.value.copy(u);const C=s(4,4),S=new Uint32Array(C.x*C.y*4);Ut.updateCenterColorsPaddedData(0,t-1,a,l,S);const y=new n.DataTexture(S,C.x,C.y,n.RGBAIntegerFormat,n.UnsignedIntType);if(y.internalFormat="RGBA32UI",y.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=y,this.material.uniforms.centersColorsTextureSize.value.copy(C),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={baseData:{covariances:o,centers:a,colors:l,sphericalHarmonics:d},covariances:{data:g,texture:f,size:u,compressionLevel:r},centerColors:{data:S,texture:y,size:C}},d){const e=2===i?n.UnsignedByteType:n.HalfFloatType;let r=h;r%2!=0&&r++;const o=2===this.minSphericalHarmonicsDegree?4:2,a=4===o?n.RGBAFormat:n.RGFormat;let l=s(o,r);if(l.x*l.y<=16777216){const s=new c(l.x*l.y*o);for(let e=0;e<t;e++){const t=h*e,n=r*e;for(let e=0;e<h;e++)s[n+e]=d[t+e]}const p=new n.DataTexture(s,l.x,l.y,a,e);p.needsUpdate=!0,this.material.uniforms.sphericalHarmonicsTexture.value=p,this.splatDataTextures.sphericalHarmonics={componentCount:h,paddedComponentCount:r,data:s,textureCount:1,texture:p,size:l,compressionLevel:i,elementsPerTexel:o}}else{const p=h/3;r=p,r%2!=0&&r++,l=s(o,r);const u=l.x*l.y*o,A=[this.material.uniforms.sphericalHarmonicsTextureR,this.material.uniforms.sphericalHarmonicsTextureG,this.material.uniforms.sphericalHarmonicsTextureB],m=[],g=[];for(let s=0;s<3;s++){const i=new c(u);m.push(i);for(let e=0;e<t;e++){const t=h*e,n=r*e;if(p>=3){for(let e=0;e<3;e++)i[n+e]=d[t+3*s+e];if(p>=8)for(let e=0;e<5;e++)i[n+3+e]=d[t+9+5*s+e]}}const o=new n.DataTexture(i,l.x,l.y,a,e);g.push(o),o.needsUpdate=!0,A[s].value=o}this.material.uniforms.sphericalHarmonicsMultiTextureMode.value=1,this.splatDataTextures.sphericalHarmonics={componentCount:h,componentCountPerChannel:p,paddedComponentCount:r,data:m,textureCount:3,textures:g,size:l,compressionLevel:i,elementsPerTexel:o}}this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(l),this.material.uniforms.sphericalHarmonics8BitMode.value=2===i?1:0,this.material.uniformsNeedUpdate=!0}if(this.dynamicMode||this.enableOptionalEffects){const e=s(1,4),r=new Uint32Array(e.x*e.y*1);for(let e=0;e<t;e++)r[e]=this.globalSplatIndexToSceneIndexMap[e];const i=new n.DataTexture(r,e.x,e.y,n.RedIntegerFormat,n.UnsignedIntType);i.internalFormat="R32UI",i.needsUpdate=!0,this.material.uniforms.sceneIndexesTexture.value=i,this.material.uniforms.sceneIndexesTextureSize.value.copy(e),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.sceneIndexes={data:r,texture:i,size:e}}}updateBaseDataFromSplatBuffers(e,t){const s=this.splatDataTextures.covariances.compressionLevel,n=this.splatDataTextures.sphericalHarmonics,r=n?n.compressionLevel:0;this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,this.splatDataTextures.baseData.sphericalHarmonics,void 0,s,r,e,t,e)}updateDataTexturesFromBaseData(e,t){const s=this.splatDataTextures.covariances.compressionLevel,n=this.splatDataTextures.sphericalHarmonics,r=n?n.compressionLevel:0,i=this.splatDataTextures.covariances,o=i.data,a=i.texture,l=6*t;for(let t=6*e;t<=l;t++){const e=this.splatDataTextures.baseData.covariances[t];o[t]=e}const c=this.renderer?this.renderer.properties.get(a):null;if(c&&c.__webglTexture){const n=s?2:4;this.updateDataTexture(o,i.texture,i.size,c,4,6,n,e,t)}else a.needsUpdate=!0;const h=this.splatDataTextures.centerColors,d=h.data,p=h.texture;Ut.updateCenterColorsPaddedData(e,t,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,d);const u=this.renderer?this.renderer.properties.get(p):null;u&&u.__webglTexture?this.updateDataTexture(d,h.texture,h.size,u,4,4,4,e,t):p.needsUpdate=!0;const A=this.splatDataTextures.baseData.sphericalHarmonics;if(A){let s=4;1===r?s=2:2===r&&(s=1);const i=(n,r,i,o,a)=>{const l=this.renderer?this.renderer.properties.get(n):null;l&&l.__webglTexture?this.updateDataTexture(o,n,r,l,i,a,s,e,t):n.needsUpdate=!0},o=n.componentCount,a=n.paddedComponentCount;if(1===n.textureCount){const s=n.data;for(let n=e;n<=t;n++){const e=o*n,t=a*n;for(let n=0;n<o;n++)s[t+n]=A[e+n]}i(n.texture,n.size,n.elementsPerTexel,s,a)}else{const s=n.componentCountPerChannel;for(let r=0;r<3;r++){const l=n.data[r];for(let n=e;n<=t;n++){const e=o*n,t=a*n;if(s>=3){for(let s=0;s<3;s++)l[t+s]=A[e+3*r+s];if(s>=8)for(let s=0;s<5;s++)l[t+3+s]=A[e+9+5*r+s]}}i(n.textures[r],n.size,n.elementsPerTexel,l,a)}}}if(this.dynamicMode){const e=this.splatDataTextures.sceneIndexes,s=e.data;for(let e=this.lastBuildSplatCount;e<=t;e++)s[e]=this.globalSplatIndexToSceneIndexMap[e];const n=e.texture,r=this.renderer?this.renderer.properties.get(n):null;r&&r.__webglTexture?this.updateDataTexture(s,e.texture,e.size,r,1,1,1,this.lastBuildSplatCount,t):n.needsUpdate=!0}}getTargetCovarianceCompressionLevel(){return this.halfPrecisionCovariancesOnGPU?1:0}getTargetSphericalHarmonicsCompressionLevel(){return Math.max(1,this.getMaximumSplatBufferCompressionLevel())}getMaximumSplatBufferCompressionLevel(){let e;for(let t=0;t<this.scenes.length;t++){const s=this.getScene(t).splatBuffer;(0===t||s.compressionLevel>e)&&(e=s.compressionLevel)}return e}getMinimumSplatBufferCompressionLevel(){let e;for(let t=0;t<this.scenes.length;t++){const s=this.getScene(t).splatBuffer;(0===t||s.compressionLevel<e)&&(e=s.compressionLevel)}return e}static computeTextureUpdateRegion(e,t,s,n,r){const i=r/n,o=e*i,a=Math.floor(o/s),l=a*s*n,c=t*i,h=Math.floor(c/s);return{dataStart:l,dataEnd:h*s*n+s*n,startRow:a,endRow:h}}updateDataTexture(e,t,s,n,r,i,o,a,l){const c=this.renderer.getContext(),h=Ut.computeTextureUpdateRegion(a,l,s.x,r,i),d=h.dataEnd-h.dataStart,p=new e.constructor(e.buffer,h.dataStart*o,d),u=h.endRow-h.startRow+1,A=this.webGLUtils.convert(t.type),m=this.webGLUtils.convert(t.format,t.colorSpace),g=c.getParameter(c.TEXTURE_BINDING_2D);c.bindTexture(c.TEXTURE_2D,n.__webglTexture),c.texSubImage2D(c.TEXTURE_2D,0,0,h.startRow,s.x,u,m,A,p),c.bindTexture(c.TEXTURE_2D,g)}static updateCenterColorsPaddedData(e,t,s,n,r){for(let l=e;l<=t;l++){const e=4*l,t=3*l,c=4*l;r[c]=(i=n)[a=e]+(i[a+1]<<8)+(i[a+2]<<16)+(i[a+3]<<24),r[c+1]=o(s[t]),r[c+2]=o(s[t+1]),r[c+3]=o(s[t+2])}var i,a}updateVisibleRegion(e){const t=this.getSplatCount(),s=new n.Vector3;if(!e){const e=new n.Vector3;this.scenes.forEach((t=>{e.add(t.splatBuffer.sceneCenter)})),e.multiplyScalar(1/this.scenes.length),this.calculatedSceneCenter.copy(e),this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),this.material.uniformsNeedUpdate=!0}for(let n=e?this.lastBuildSplatCount:0;n<t;n++){this.getSplatCenter(n,s,!1);const e=s.sub(this.calculatedSceneCenter).length();e>this.maxSplatDistanceFromSceneCenter&&(this.maxSplatDistanceFromSceneCenter=e)}this.maxSplatDistanceFromSceneCenter-this.visibleRegionBufferRadius>1&&(this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter,this.visibleRegionRadius=Math.max(this.visibleRegionBufferRadius-1,0)),this.finalBuild&&(this.visibleRegionRadius=this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter),this.updateVisibleRegionFadeDistance()}updateVisibleRegionFadeDistance(e=Ht.Default){const t=this.finalBuild?.012:.003,s=e===Ht.Default?t:.003;this.visibleRegionFadeStartRadius=(this.visibleRegionRadius-this.visibleRegionFadeStartRadius)*s+this.visibleRegionFadeStartRadius;const n=(this.visibleRegionBufferRadius>0?this.visibleRegionFadeStartRadius/this.visibleRegionBufferRadius:0)>.99,r=n||e===Ht.Instant?1:0;this.material.uniforms.visibleRegionFadeStartRadius.value=this.visibleRegionFadeStartRadius,this.material.uniforms.visibleRegionRadius.value=this.visibleRegionRadius,this.material.uniforms.firstRenderTime.value=this.firstRenderTime,this.material.uniforms.currentTime.value=performance.now(),this.material.uniforms.fadeInComplete.value=r,this.material.uniformsNeedUpdate=!0,this.visibleRegionChanging=!n}updateRenderIndexes(e,t){const s=this.geometry;s.attributes.splatIndex.set(e),s.attributes.splatIndex.needsUpdate=!0,t>0&&-1===this.firstRenderTime&&(this.firstRenderTime=performance.now()),s.instanceCount=t}updateTransforms(){for(let e=0;e<this.scenes.length;e++){this.getScene(e).updateTransform()}}updateUniforms=function(){const e=new n.Vector2;return function(t,s,n,r,i,o){if(this.getSplatCount()>0){if(e.set(t.x*this.devicePixelRatio,t.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(1/e.x,1/e.y),this.material.uniforms.focal.value.set(s,n),this.material.uniforms.orthographicMode.value=r?1:0,this.material.uniforms.orthoZoom.value=i,this.material.uniforms.inverseFocalAdjustment.value=o,this.dynamicMode)for(let e=0;e<this.scenes.length;e++)this.material.uniforms.transforms.value[e].copy(this.getScene(e).transform);if(this.enableOptionalEffects)for(let e=0;e<this.scenes.length;e++)this.material.uniforms.sceneOpacity.value[e]=l(this.getScene(e).opacity,0,1),this.material.uniforms.sceneVisibility.value[e]=this.getScene(e).visible?1:0,this.material.uniformsNeedUpdate=!0;this.material.uniformsNeedUpdate=!0}}}();setSplatScale(e=1){this.splatScale=e,this.material.uniforms.splatScale.value=e,this.material.uniformsNeedUpdate=!0}getSplatScale(){return this.splatScale}setPointCloudModeEnabled(e){this.pointCloudModeEnabled=e,this.material.uniforms.pointCloudModeEnabled.value=e?1:0,this.material.uniformsNeedUpdate=!0}getPointCloudModeEnabled(){return this.pointCloudModeEnabled}getSplatDataTextures(){return this.splatDataTextures}getSplatCount(){return Ut.getTotalSplatCountForScenes(this.scenes)}static getTotalSplatCountForScenes(e){let t=0;for(let s of e)s&&s.splatBuffer&&(t+=s.splatBuffer.getSplatCount());return t}static getTotalSplatCountForSplatBuffers(e){let t=0;for(let s of e)t+=s.getSplatCount();return t}getMaxSplatCount(){return Ut.getTotalMaxSplatCountForScenes(this.scenes)}static getTotalMaxSplatCountForScenes(e){let t=0;for(let s of e)s&&s.splatBuffer&&(t+=s.splatBuffer.getMaxSplatCount());return t}static getTotalMaxSplatCountForSplatBuffers(e){let t=0;for(let s of e)t+=s.getMaxSplatCount();return t}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){if(e!==this.renderer){this.renderer=e;const t=this.renderer.getContext(),s=new Pt(t),r=new kt(t,s,{});if(s.init(r),this.webGLUtils=new n.WebGLUtils(t,s,r),this.enableDistancesComputationOnGPU&&this.getSplatCount()>0){this.setupDistancesComputationTransformFeedback();const{centers:e,sceneIndexes:t}=this.getDataForDistancesComputation(0,this.getSplatCount()-1);this.refreshGPUBuffersForDistancesComputation(e,t)}}}setupDistancesComputationTransformFeedback=function(){let e;return function(){const t=this.getMaxSplatCount();if(!this.renderer)return;const s=this.lastRenderer!==this.renderer,n=e!==t;if(!s&&!n)return;s?this.disposeDistancesComputationGPUResources():n&&this.disposeDistancesComputationGPUBufferResources();const r=this.renderer.getContext(),i=(e,t,s)=>{const n=e.createShader(t);if(!n)return console.error("Fatal error: gl could not create a shader object."),null;e.shaderSource(n,s),e.compileShader(n);if(!e.getShaderParameter(n,e.COMPILE_STATUS)){let s="unknown";t===e.VERTEX_SHADER?s="vertex shader":t===e.FRAGMENT_SHADER&&(s="fragement shader");const r=e.getShaderInfoLog(n);return console.error("Failed to compile "+s+" with these errors:"+r),e.deleteShader(n),null}return n};let o;this.integerBasedDistancesComputation?(o="#version 300 es\n                in ivec4 center;\n                flat out int distance;",this.dynamicMode?o+=`\n                        in uint sceneIndex;\n                        uniform ivec4 transforms[${S.MaxScenes}];\n                        void main(void) {\n                            ivec4 transform = transforms[sceneIndex];\n                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;\n                        }\n                    `:o+="\n                        uniform ivec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    "):(o="#version 300 es\n                in vec4 center;\n                flat out float distance;",this.dynamicMode?o+=`\n                        in uint sceneIndex;\n                        uniform mat4 transforms[${S.MaxScenes}];\n                        void main(void) {\n                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);\n                            distance = transformedCenter.z;\n                        }\n                    `:o+="\n                        uniform vec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    ");const a=r.getParameter(r.VERTEX_ARRAY_BINDING),l=r.getParameter(r.CURRENT_PROGRAM),c=!!l&&r.getProgramParameter(l,r.DELETE_STATUS);if(s&&(this.distancesTransformFeedback.vao=r.createVertexArray()),r.bindVertexArray(this.distancesTransformFeedback.vao),s){const e=r.createProgram(),t=i(r,r.VERTEX_SHADER,o),s=i(r,r.FRAGMENT_SHADER,"#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            ");if(!t||!s)throw new Error("Could not compile shaders for distances computation on GPU.");r.attachShader(e,t),r.attachShader(e,s),r.transformFeedbackVaryings(e,["distance"],r.SEPARATE_ATTRIBS),r.linkProgram(e);if(!r.getProgramParameter(e,r.LINK_STATUS)){const n=r.getProgramInfoLog(e);throw console.error("Fatal error: Failed to link program: "+n),r.deleteProgram(e),r.deleteShader(s),r.deleteShader(t),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=e,this.distancesTransformFeedback.vertexShader=t,this.distancesTransformFeedback.vertexShader=s}if(r.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=r.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.sceneIndexesLoc=r.getAttribLocation(this.distancesTransformFeedback.program,"sceneIndex");for(let e=0;e<this.scenes.length;e++)this.distancesTransformFeedback.transformsLocs[e]=r.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${e}]`)}else this.distancesTransformFeedback.modelViewProjLoc=r.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(s||n)&&(this.distancesTransformFeedback.centersBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?r.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,r.INT,0,0):r.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,r.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.sceneIndexesBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),r.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,r.UNSIGNED_INT,0,0))),(s||n)&&(this.distancesTransformFeedback.outDistancesBuffer=r.createBuffer()),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),r.bufferData(r.ARRAY_BUFFER,4*t,r.STATIC_READ),s&&(this.distancesTransformFeedback.id=r.createTransformFeedback()),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),l&&!0!==c&&r.useProgram(l),a&&r.bindVertexArray(a),this.lastRenderer=this.renderer,e=t}}();updateGPUCentersBufferForDistancesComputation(e,t,s){if(!this.renderer)return;const n=this.renderer.getContext(),r=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=this.integerBasedDistancesComputation?Uint32Array:Float32Array,o=16*s;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e)n.bufferSubData(n.ARRAY_BUFFER,o,t);else{const e=new i(16*this.getMaxSplatCount());e.set(t),n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),r&&n.bindVertexArray(r)}updateGPUTransformIndexesBufferForDistancesComputation(e,t,s){if(!this.renderer||!this.dynamicMode)return;const n=this.renderer.getContext(),r=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=4*s;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),e)n.bufferSubData(n.ARRAY_BUFFER,i,t);else{const e=new Uint32Array(4*this.getMaxSplatCount());e.set(t),n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),r&&n.bindVertexArray(r)}getSceneIndexes(e,t){let s;s=new Uint32Array(t-e+1);for(let n=e;n<=t;n++)s[n]=this.globalSplatIndexToSceneIndexMap[n];return s}fillTransformsArray=function(){const e=[];return function(t){e.length!==t.length&&(e.length=t.length);for(let t=0;t<this.scenes.length;t++){const s=this.getScene(t).transform.elements;for(let n=0;n<16;n++)e[16*t+n]=s[n]}t.set(e)}}();computeDistancesOnGPU=function(){const e=new n.Matrix4;return function(t,s){if(!this.renderer)return;const n=this.renderer.getContext(),r=n.getParameter(n.VERTEX_ARRAY_BINDING),i=n.getParameter(n.CURRENT_PROGRAM),o=!!i&&n.getProgramParameter(i,n.DELETE_STATUS);if(n.bindVertexArray(this.distancesTransformFeedback.vao),n.useProgram(this.distancesTransformFeedback.program),n.enable(n.RASTERIZER_DISCARD),this.dynamicMode)for(let s=0;s<this.scenes.length;s++)if(e.copy(this.getScene(s).transform),e.premultiply(t),this.integerBasedDistancesComputation){const t=Ut.getIntegerMatrixArray(e),r=[t[2],t[6],t[10],t[14]];n.uniform4i(this.distancesTransformFeedback.transformsLocs[s],r[0],r[1],r[2],r[3])}else n.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[s],!1,e.elements);else if(this.integerBasedDistancesComputation){const e=Ut.getIntegerMatrixArray(t),s=[e[2],e[6],e[10]];n.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,s[0],s[1],s[2])}else{const e=[t.elements[2],t.elements[6],t.elements[10]];n.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,e[0],e[1],e[2])}n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?n.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,n.INT,0,0):n.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,n.FLOAT,!1,0,0),this.dynamicMode&&(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),n.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,n.UNSIGNED_INT,0,0)),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),n.beginTransformFeedback(n.POINTS),n.drawArrays(n.POINTS,0,this.getSplatCount()),n.endTransformFeedback(),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,null),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null),n.disable(n.RASTERIZER_DISCARD);const a=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush();const l=new Promise((e=>{const t=()=>{if(this.disposed)e();else{const r=0,i=0;switch(n.clientWaitSync(a,i,r)){case n.TIMEOUT_EXPIRED:return this.computeDistancesOnGPUSyncTimeout=setTimeout(t),this.computeDistancesOnGPUSyncTimeout;case n.WAIT_FAILED:throw new Error("should never get here");default:this.computeDistancesOnGPUSyncTimeout=null,n.deleteSync(a);const r=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao),n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),n.getBufferSubData(n.ARRAY_BUFFER,0,s),n.bindBuffer(n.ARRAY_BUFFER,null),r&&n.bindVertexArray(r),e()}}};this.computeDistancesOnGPUSyncTimeout=setTimeout(t)}));return i&&!0!==o&&n.useProgram(i),r&&n.bindVertexArray(r),l}}();getLocalSplatParameters(e,t,s){null==s&&(s=!this.dynamicMode),t.splatBuffer=this.getSplatBufferForSplat(e),t.localIndex=this.getSplatLocalIndex(e),t.sceneTransform=s?this.getSceneTransformForSplat(e):null}fillSplatDataArrays(e,t,s,n,r,i=0,o=1,a,l,c=0){for(let h=0;h<this.scenes.length;h++){null==r&&(r=!this.dynamicMode);const d=this.getScene(h),p=d.splatBuffer,u=r?d.transform:null;e&&p.fillSplatCovarianceArray(e,u,a,l,c,i),t&&p.fillSplatCenterArray(t,u,a,l,c),s&&p.fillSplatColorArray(s,d.minimumAlpha,a,l,c),n&&p.fillSphericalHarmonicsArray(n,this.minSphericalHarmonicsDegree,u,a,l,c,o),c+=p.getSplatCount()}}getIntegerCenters(e,t,s=!1){const n=t-e+1,r=new Float32Array(3*n);let i;this.fillSplatDataArrays(null,r,null,null,void 0,void 0,void 0,e);let o=s?4:3;i=new Int32Array(n*o);for(let e=0;e<n;e++){for(let t=0;t<3;t++)i[e*o+t]=Math.round(1e3*r[3*e+t]);s&&(i[e*o+3]=1e3)}return i}getFloatCenters(e,t,s=!1){const n=t-e+1,r=new Float32Array(3*n);if(this.fillSplatDataArrays(null,r,null,null,void 0,void 0,void 0,e),!s)return r;let i=new Float32Array(4*n);for(let e=0;e<n;e++){for(let t=0;t<3;t++)i[4*e+t]=r[3*e+t];i[4*e+3]=1}return i}getSplatCenter=function(){const e={};return function(t,s,n){this.getLocalSplatParameters(t,e,n),e.splatBuffer.getSplatCenter(e.localIndex,s,e.sceneTransform)}}();getSplatScaleAndRotation=function(){const e={};return function(t,s,n,r){this.getLocalSplatParameters(t,e,r),e.splatBuffer.getSplatScaleAndRotation(e.localIndex,s,n,e.sceneTransform)}}();getSplatColor=function(){const e={};return function(t,s){this.getLocalSplatParameters(t,e),e.splatBuffer.getSplatColor(e.localIndex,s)}}();getSceneTransform(e,t){const s=this.getScene(e);s.updateTransform(),t.copy(s.transform)}getScene(e){if(e<0||e>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[e]}getSplatBufferForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).splatBuffer}getSceneIndexForSplat(e){return this.globalSplatIndexToSceneIndexMap[e]}getSceneTransformForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).transform}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}static getIntegerMatrixArray(e){const t=e.elements,s=[];for(let e=0;e<16;e++)s[e]=Math.round(1e3*t[e]);return s}}var Qt="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";function zt(e){let t,s,n,r,i,o,a,l,c,h,d,p,u,A,m,g,f,C;e.onmessage=S=>{if(S.data.centers)centers=S.data.centers,sceneIndexes=S.data.sceneIndexes,r?new Int32Array(s,A+S.data.range.from*C.BytesPerInt*4,4*S.data.range.count).set(new Int32Array(centers)):new Float32Array(s,A+S.data.range.from*C.BytesPerFloat*4,4*S.data.range.count).set(new Float32Array(centers)),i&&new Uint32Array(s,c+4*S.data.range.from,S.data.range.count).set(new Uint32Array(sceneIndexes)),e.postMessage({centerDataSet:!0});else if(S.data.sort){const y=S.data.sort.splatRenderCount||0,x=S.data.sort.splatSortCount||0,I=S.data.sort.usePrecomputedDistances;let v,B,w;n||(v=S.data.sort.indexesToSort,w=S.data.sort.transforms,I&&(B=S.data.sort.precomputedDistances)),function(S,y,x,I,v,B,w){const b=performance.now();if(!n&&(new Uint32Array(s,a,v.byteLength/C.BytesPerInt).set(v),new Float32Array(s,h,w.byteLength/C.BytesPerFloat).set(w),I)){let e;e=r?new Int32Array(s,d,B.byteLength/C.BytesPerInt):new Float32Array(s,d,B.byteLength/C.BytesPerFloat),e.set(B)}g||(g=new Uint32Array(C.DepthMapRange)),new Float32Array(s,m,16).set(x),new Uint32Array(s,u,C.DepthMapRange).set(g),t.exports.sortIndexes(a,A,d,p,u,m,l,c,h,C.DepthMapRange,S,y,o,I,r,i);const E={sortDone:!0,splatSortCount:S,splatRenderCount:y,sortTime:0};if(!n){const e=new Uint32Array(s,l,y);(!f||f.length<y)&&(f=new Uint32Array(y)),f.set(e),E.sortedIndexes=f}const D=performance.now();E.sortTime=D-b,e.postMessage(E)}(x,y,S.data.sort.modelViewProj,I,v,B,w)}else if(S.data.init){C=S.data.init.Constants,o=S.data.init.splatCount,n=S.data.init.useSharedMemory,r=S.data.init.integerBasedSort,i=S.data.init.dynamicMode;const g=r?4*C.BytesPerInt:4*C.BytesPerFloat,f=new Uint8Array(S.data.init.sorterWasmBytes),y=16*C.BytesPerFloat,x=o*C.BytesPerInt,I=o*g,v=y,B=r?o*C.BytesPerInt:o*C.BytesPerFloat,w=o*C.BytesPerInt,b=o*C.BytesPerInt,E=C.DepthMapRange*C.BytesPerInt*2,D=i?o*C.BytesPerInt:0,T=i?C.MaxScenes*y:0,M=32*C.MemoryPageSize,F=x+I+v+B+w+E+b+D+T+M,R=Math.floor(F/C.MemoryPageSize)+1,P={module:{},env:{memory:new WebAssembly.Memory({initial:R,maximum:R,shared:!0})}};WebAssembly.compile(f).then((e=>WebAssembly.instantiate(e,P))).then((r=>{t=r,a=0,A=a+x,m=A+I,d=m+v,p=d+B,u=p+w,l=u+E,c=l+b,h=c+D,s=P.env.memory.buffer,n?e.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:s,indexesToSortOffset:a,sortedIndexesBuffer:s,sortedIndexesOffset:l,precomputedDistancesBuffer:s,precomputedDistancesOffset:d,transformsBuffer:s,transformsOffset:h}):e.postMessage({sortSetupPhase1Complete:!0})}))}}}const Vt={None:0,VR:1,AR:2};class Nt{static createButton(e){const t=document.createElement("button");function s(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function n(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",n(t),navigator.xr.isSessionSupported("immersive-vr").then((function(n){n?function(){let s=null;async function n(n){n.addEventListener("end",r),await e.xr.setSession(n),t.textContent="EXIT VR",s=n}function r(){s.removeEventListener("end",r),t.textContent="ENTER VR",s=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR";const i={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){null===s?navigator.xr.requestSession("immersive-vr",i).then(n):(s.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",i).then(n).catch((e=>{console.warn(e)})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",i).then(n).catch((e=>{console.warn(e)}))}():(s(),t.textContent="VR NOT SUPPORTED"),n&&Nt.xrSessionIsGranted&&t.click()})).catch((function(e){s(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",n(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{Nt.xrSessionIsGranted=!0}))}}}Nt.xrSessionIsGranted=!1,Nt.registerSessionGrantedListener();class Gt{static createButton(e,t={}){const s=document.createElement("button");function n(){s.style.display="",s.style.cursor="auto",s.style.left="calc(50% - 75px)",s.style.width="150px",s.onmouseenter=null,s.onmouseleave=null,s.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return s.id="ARButton",s.style.display="none",r(s),navigator.xr.isSessionSupported("immersive-ar").then((function(r){r?function(){if(void 0===t.domOverlay){const e=document.createElement("div");e.style.display="none",document.body.appendChild(e);const s=document.createElementNS("http://www.w3.org/2000/svg","svg");s.setAttribute("width",38),s.setAttribute("height",38),s.style.position="absolute",s.style.right="20px",s.style.top="20px",s.addEventListener("click",(function(){n.end()})),e.appendChild(s);const r=document.createElementNS("http://www.w3.org/2000/svg","path");r.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),r.setAttribute("stroke","#fff"),r.setAttribute("stroke-width",2),s.appendChild(r),void 0===t.optionalFeatures&&(t.optionalFeatures=[]),t.optionalFeatures.push("dom-overlay"),t.domOverlay={root:e}}let n=null;async function r(r){r.addEventListener("end",i),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(r),s.textContent="STOP AR",t.domOverlay.root.style.display="",n=r}function i(){n.removeEventListener("end",i),s.textContent="START AR",t.domOverlay.root.style.display="none",n=null}s.style.display="",s.style.cursor="pointer",s.style.left="calc(50% - 50px)",s.style.width="100px",s.textContent="START AR",s.onmouseenter=function(){s.style.opacity="1.0"},s.onmouseleave=function(){s.style.opacity="0.5"},s.onclick=function(){null===n?navigator.xr.requestSession("immersive-ar",t).then(r):(n.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(r).catch((e=>{console.warn(e)})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(r).catch((e=>{console.warn(e)}))}():(n(),s.textContent="AR NOT SUPPORTED")})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),s.textContent="AR NOT ALLOWED"})),s;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}}const Kt={Always:0,OnChange:1,Never:2};class jt{constructor(e={}){if(e.cameraUp||(e.cameraUp=[0,1,0]),this.cameraUp=(new n.Vector3).fromArray(e.cameraUp),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),this.initialCameraPosition=(new n.Vector3).fromArray(e.initialCameraPosition),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=(new n.Vector3).fromArray(e.initialCameraLookAt),this.dropInMode=e.dropInMode||!1,void 0!==e.selfDrivenMode&&null!==e.selfDrivenMode||(e.selfDrivenMode=!0),this.selfDrivenMode=e.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),void 0===e.useBuiltInControls&&(e.useBuiltInControls=!0),this.useBuiltInControls=e.useBuiltInControls,this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio,this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU||!1,this.threeScene=e.threeScene,this.renderer=e.renderer,this.camera=e.camera,this.gpuAcceleratedSort=e.gpuAcceleratedSort||!1,void 0!==e.integerBasedSort&&null!==e.integerBasedSort||(e.integerBasedSort=!0),this.integerBasedSort=e.integerBasedSort,void 0!==e.sharedMemoryForWorkers&&null!==e.sharedMemoryForWorkers||(e.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=e.sharedMemoryForWorkers,this.dynamicScene=!!e.dynamicScene,this.antialiased=e.antialiased||!1,this.webXRMode=e.webXRMode||Vt.None,this.webXRMode!==Vt.None&&(this.gpuAcceleratedSort=!1),this.webXRActive=!1,this.renderMode=e.renderMode||Kt.Always,this.sceneRevealMode=e.sceneRevealMode||Ht.Default,this.focalAdjustment=e.focalAdjustment||1,this.maxScreenSpaceSplatSize=e.maxScreenSpaceSplatSize||1024,this.logLevel=e.logLevel||Lt.None,this.sphericalHarmonicsDegree=e.sphericalHarmonicsDegree||0,this.enableOptionalEffects=e.enableOptionalEffects||!1,void 0!==e.enableSIMDInSort&&null!==e.enableSIMDInSort||(e.enableSIMDInSort=!0),this.enableSIMDInSort=e.enableSIMDInSort,void 0!==e.plyInMemoryCompressionLevel&&null!==e.plyInMemoryCompressionLevel||(e.plyInMemoryCompressionLevel=2),this.plyInMemoryCompressionLevel=e.plyInMemoryCompressionLevel,void 0!==e.freeIntermediateSplatData&&null!==e.freeIntermediateSplatData||(e.freeIntermediateSplatData=!1),this.freeIntermediateSplatData=e.freeIntermediateSplatData,g()){const e=f();e.major<17&&(this.enableSIMDInSort=!1),e.major<16&&(this.sharedMemoryForWorkers=!1)}this.createSplatMesh(),this.controls=null,this.perspectiveControls=null,this.orthographicControls=null,this.orthographicCamera=null,this.perspectiveCamera=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.runAfterNextSort=[],this.selfDrivenModeRunning=!1,this.splatRenderReady=!1,this.raycaster=new wt,this.infoPanel=null,this.startInOrthographicMode=!1,this.currentFPS=0,this.lastSortTime=0,this.consecutiveRenderFrames=0,this.previousCameraTarget=new n.Vector3,this.nextCameraTarget=new n.Vector3,this.mousePosition=new n.Vector2,this.mouseDownPosition=new n.Vector2,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.splatSceneDownloadPromises={},this.splatSceneDownloadAndBuildPromise=null,this.splatSceneRemovalPromise=null,this.loadingSpinner=new mt(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.loadingProgressBar=new gt(this.rootElement||document.body),this.loadingProgressBar.hide(),this.infoPanel=new ft(this.rootElement||document.body),this.infoPanel.hide(),this.usingExternalCamera=!(!this.dropInMode&&!this.camera),this.usingExternalRenderer=!(!this.dropInMode&&!this.renderer),this.initialized=!1,this.disposing=!1,this.disposed=!1,this.dropInMode||this.init()}createSplatMesh(){this.splatMesh=new Ut(this.dynamicScene,this.enableOptionalEffects,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort,this.antialiased,this.maxScreenSpaceSplatSize,this.logLevel,this.sphericalHarmonicsDegree),this.splatMesh.frustumCulled=!1}init(){this.initialized||(this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement.parentElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement))),this.setupCamera(),this.setupRenderer(),this.setupWebXR(),this.setupControls(),this.setupEventHandlers(),this.threeScene=this.threeScene||new n.Scene,this.sceneHelper=new St(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.loadingProgressBar.setContainer(this.rootElement),this.loadingSpinner.setContainer(this.rootElement),this.infoPanel.setContainer(this.rootElement),this.initialized=!0)}setupCamera(){if(!this.usingExternalCamera){const e=new n.Vector2;this.getRenderDimensions(e),this.perspectiveCamera=new n.PerspectiveCamera(50,e.x/e.y,.1,1e3),this.orthographicCamera=new n.OrthographicCamera(e.x/-2,e.x/2,e.y/2,e.y/-2,.1,1e3),this.camera=this.startInOrthographicMode?this.orthographicCamera:this.perspectiveCamera,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)}}setupRenderer(){if(!this.usingExternalRenderer){const e=new n.Vector2;this.getRenderDimensions(e),this.renderer=new n.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new n.Color(0),0),this.renderer.setSize(e.x,e.y),this.resizeObserver=new ResizeObserver((()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y),this.forceRenderNextFrame()})),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}}setupWebXR(){this.webXRMode&&(this.webXRMode===Vt.VR?this.rootElement.appendChild(Nt.createButton(this.renderer)):this.webXRMode===Vt.AR&&this.rootElement.appendChild(Gt.createButton(this.renderer)),this.renderer.xr.addEventListener("sessionstart",(e=>{this.webXRActive=!0})),this.renderer.xr.addEventListener("sessionend",(e=>{this.webXRActive=!1})),this.renderer.xr.enabled=!0,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt))}setupControls(){if(this.useBuiltInControls&&this.webXRMode===Vt.None){this.usingExternalCamera?this.camera.isOrthographicCamera?this.orthographicControls=new At(this.camera,this.renderer.domElement):this.perspectiveControls=new At(this.camera,this.renderer.domElement):(this.perspectiveControls=new At(this.perspectiveCamera,this.renderer.domElement),this.orthographicControls=new At(this.orthographicCamera,this.renderer.domElement));for(let e of[this.perspectiveControls,this.orthographicControls])e&&(e.listenToKeyEvents(window),e.rotateSpeed=.5,e.maxPolarAngle=.75*Math.PI,e.minPolarAngle=.1,e.enableDamping=!0,e.dampingFactor=.05,e.target.copy(this.initialCameraLookAt));this.controls=this.camera.isOrthographicCamera?this.orthographicControls:this.perspectiveControls}}setupEventHandlers(){this.useBuiltInControls&&this.webXRMode===Vt.None&&(this.mouseMoveListener=this.onMouseMove.bind(this),this.renderer.domElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.renderer.domElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.renderer.domElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1))}removeEventHandlers(){this.useBuiltInControls&&(this.renderer.domElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.renderer.domElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.renderer.domElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}setRenderMode(e){this.renderMode=e}onKeyDown=function(){const e=new n.Vector3,t=new n.Matrix4,s=new n.Matrix4;return function(n){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),t.makeRotationAxis(e,Math.PI/128),s.makeRotationAxis(e,-Math.PI/128),n.code){case"KeyG":this.focalAdjustment+=.02,this.forceRenderNextFrame();break;case"KeyF":this.focalAdjustment-=.02,this.forceRenderNextFrame();break;case"ArrowLeft":this.camera.up.transformDirection(t);break;case"ArrowRight":this.camera.up.transformDirection(s);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyU":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.show():this.infoPanel.hide();break;case"KeyO":this.usingExternalCamera||this.setOrthographicMode(!this.camera.isOrthographicCamera);break;case"KeyP":this.usingExternalCamera||this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());break;case"Equal":this.usingExternalCamera||this.splatMesh.setSplatScale(this.splatMesh.getSplatScale()+.05);break;case"Minus":this.usingExternalCamera||this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale()-.05,0))}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=c()}onMouseUp=function(){const e=new n.Vector2;return function(t){e.copy(this.mousePosition).sub(this.mouseDownPosition);c()-this.mouseDownTime<.5&&e.length()<2&&this.onMouseClick(t)}}();onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}checkForFocalPointChange=function(){const e=new n.Vector2,t=new n.Vector3,s=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(e),s.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.raycaster.intersectSplatMesh(this.splatMesh,s),s.length>0)){const e=s[0].origin;t.copy(e).sub(this.camera.position),t.length()>.75&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(e),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=c())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setOrthographicMode(e){if(e===this.camera.isOrthographicCamera)return;const t=this.camera,s=e?this.orthographicCamera:this.perspectiveCamera;if(s.position.copy(t.position),s.up.copy(t.up),s.rotation.copy(t.rotation),s.quaternion.copy(t.quaternion),s.matrix.copy(t.matrix),this.camera=s,this.controls){const n=e=>{e.saveState(),e.reset()},r=this.controls,i=e?this.orthographicControls:this.perspectiveControls;n(i),n(r),i.target.copy(r.target),e?jt.setCameraZoomFromPosition(s,t,r):jt.setCameraPositionFromZoom(s,t,i),this.controls=i,this.camera.lookAt(this.controls.target)}}static setCameraPositionFromZoom=function(){const e=new n.Vector3;return function(t,s,n){const r=1/(.001*s.zoom);e.copy(n.target).sub(t.position).normalize().multiplyScalar(r).negate(),t.position.copy(n.target).add(e)}}();static setCameraZoomFromPosition=function(){const e=new n.Vector3;return function(t,s,n){const r=e.copy(n.target).sub(s.position).length();t.zoom=1/(.001*r)}}();updateSplatMesh=function(){const e=new n.Vector2;return function(){if(!this.splatMesh)return;if(this.splatMesh.getSplatCount()>0){this.splatMesh.updateTransforms(),this.getRenderDimensions(e);const t=.5*this.camera.projectionMatrix.elements[0]*this.devicePixelRatio*e.x,s=.5*this.camera.projectionMatrix.elements[5]*this.devicePixelRatio*e.y,n=this.camera.isOrthographicCamera?1/this.devicePixelRatio:1,r=this.focalAdjustment*n,i=1/r;this.adjustForWebXRStereo(e),this.splatMesh.updateUniforms(e,t*r,s*r,this.camera.isOrthographicCamera,this.camera.zoom||1,i)}}}();adjustForWebXRStereo(e){if(this.camera&&this.webXRActive){const t=this.renderer.xr.getCamera().projectionMatrix.elements[0],s=this.camera.projectionMatrix.elements[0];e.x*=s/t}}isLoadingOrUnloading(){return Object.keys(this.splatSceneDownloadPromises).length>0||null!==this.splatSceneDownloadAndBuildPromise||null!==this.splatSceneRemovalPromise}isDisposingOrDisposed(){return this.disposing||this.disposed}addSplatSceneDownloadPromise(e){this.splatSceneDownloadPromises[e.id]=e}removeSplatSceneDownloadPromise(e){delete this.splatSceneDownloadPromises[e.id]}setSplatSceneDownloadAndBuildPromise(e){this.splatSceneDownloadAndBuildPromise=e}clearSplatSceneDownloadAndBuildPromise(){this.splatSceneDownloadAndBuildPromise=null}addSplatScene(e,t={}){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");t.progressiveLoad&&this.splatMesh.scenes&&this.splatMesh.scenes.length>0&&(console.log('addSplatScene(): "progressiveLoad" option ignore because there are multiple splat scenes'),t.progressiveLoad=!1);const s=void 0!==t.format&&null!==t.format?t.format:ot(e),n=jt.isProgressivelyLoadable(s)&&t.progressiveLoad,r=void 0===t.showLoadingUI||null===t.showLoadingUI||t.showLoadingUI;let i=null;r&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const o=(e,t,s)=>{if(r)if(s===Je)if(100==e)this.loadingSpinner.setMessageForTask(i,"Download complete!");else if(n)this.loadingSpinner.setMessageForTask(i,"Downloading splats...");else{const e=t?`: ${t}`:"...";this.loadingSpinner.setMessageForTask(i,`Downloading${e}`)}else s===Ze&&this.loadingSpinner.setMessageForTask(i,"Processing splats...")};let a=!1,l=0;const c=(e,t)=>{r&&((e&&n||t&&!n)&&(this.loadingSpinner.removeTask(i),t||a||this.loadingProgressBar.show()),n&&(t?(a=!0,this.loadingProgressBar.hide()):this.loadingProgressBar.setProgress(l)))};return(n?this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this):this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this))(e,s,t.splatAlphaRemovalThreshold,((e,s,i)=>{!n&&t.onProgress&&t.onProgress(0,"0%",Ze);const o={rotation:t.rotation||t.orientation,position:t.position,scale:t.scale,splatAlphaRemovalThreshold:t.splatAlphaRemovalThreshold};return this.addSplatBuffers([e],[o],i,s&&r,r,n,n).then((()=>{!n&&t.onProgress&&t.onProgress(100,"100%",Ze),c(s,i)}))}).bind(this),((e,s,n)=>{l=e,o(e,s,n),t.onProgress&&t.onProgress(e,s,n)}),(()=>{this.loadingProgressBar.hide(),this.loadingSpinner.removeAllTasks()}).bind(this))}downloadAndBuildSingleSplatSceneStandardLoad(e,t,s,n,r,o){const a=u(),l=this.downloadSplatSceneToSplatBuffer(e,s,r,!1,void 0,t).then((e=>(this.removeSplatSceneDownloadPromise(l),n(e,!0,!0).then((()=>{a.resolve(),this.clearSplatSceneDownloadAndBuildPromise()}))))).catch((t=>{if(o&&o(),a.reject(),this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(l),!(t instanceof i))throw new Error(`Viewer::addSplatScene -> Could not load file ${e}`)}));return this.addSplatSceneDownloadPromise(l),this.setSplatSceneDownloadAndBuildPromise(a.promise),a.promise}downloadAndBuildSingleSplatSceneProgressiveLoad(e,t,s,n,r,o){let a=0,l=!1;const c=[],h=()=>{if(c.length>0&&!l&&!this.isDisposingOrDisposed()){l=!0;const e=c.shift();n(e.splatBuffer,e.firstBuild,e.finalBuild).then((()=>{l=!1,e.firstBuild?(u.reject=null,u.resolve()):e.finalBuild&&(m.resolve(),this.clearSplatSceneDownloadAndBuildPromise()),c.length>0&&d((()=>h()))}))}};let p=this.downloadSplatSceneToSplatBuffer(e,s,r,!0,((e,t)=>{this.isDisposingOrDisposed()||(t||0===c.length||e.getSplatCount()>c[0].splatBuffer.getSplatCount())&&(c.push({splatBuffer:e,firstBuild:0===a,finalBuild:t}),a++,h())}),t);const u=A(p.abortHandler),m=A();return this.addSplatSceneDownloadPromise(p),this.setSplatSceneDownloadAndBuildPromise(m.promise),p.then((()=>{this.removeSplatSceneDownloadPromise(p)})).catch((e=>{this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(p),e instanceof i||(m.reject(e),u.reject&&u.reject(e),o&&o(e))})),u.promise}addSplatScenes(e,t=!0,s=void 0){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");const n=e.length,o=[];let a;t&&(this.loadingSpinner.removeAllTasks(),a=this.loadingSpinner.addTask("Downloading..."));const l=(e,r,i,l)=>{o[e]=r;let c=0;for(let e=0;e<n;e++)c+=o[e]||0;c/=n,i=`${c.toFixed(2)}%`,t&&l===Je&&this.loadingSpinner.setMessageForTask(a,100==c?"Download complete!":`Downloading: ${i}`),s&&s(c,i,l)},c=[],h=[],d=[];for(let t=0;t<e.length;t++){const s=e[t],n=void 0!==s.format&&null!==s.format?s.format:ot(s.path),r=this.downloadSplatSceneToSplatBuffer(s.path,s.splatAlphaRemovalThreshold,l.bind(this,t),!1,void 0,n);d.push(r.abortHandler),c.push(r),h.push(r.promise),this.addSplatSceneDownloadPromise(r)}const p=new r(((n,r)=>{Promise.all(h).then((r=>{t&&this.loadingSpinner.removeTask(a),s&&s(0,"0%",Ze),this.addSplatBuffers(r,e,!0,t,t,!1,!1).then((()=>{s&&s(100,"100%",Ze),this.clearSplatSceneDownloadAndBuildPromise(),n()}))})).catch((e=>{t&&this.loadingSpinner.removeTask(a),this.clearSplatSceneDownloadAndBuildPromise(),e instanceof i?n():r(new Error("Viewer::addSplatScenes -> Could not load one or more splat scenes."))})).finally((()=>{for(let e of c)this.removeSplatSceneDownloadPromise(e)}))}),(()=>{for(let e of d)e()}));return this.setSplatSceneDownloadAndBuildPromise(p),p}downloadSplatSceneToSplatBuffer(e,t=1,s=void 0,n=!1,i=void 0,o){return o===it.Splat?nt.loadFromURL(e,s,n,i,t,0,!1):o===it.KSplat?rt.loadFromURL(e,s,n,i):o===it.Ply?tt.loadFromURL(e,s,n,i,t,this.plyInMemoryCompressionLevel,this.sphericalHarmonicsDegree):r.reject(new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${e}`))}static isProgressivelyLoadable(e){return e===it.Splat||e===it.KSplat||e===it.Ply}addSplatBuffers=function(){return function(e,t=[],s=!0,n=!0,r=!0,i=!1,o=!1,a=!0){if(this.isDisposingOrDisposed())return Promise.resolve();this.splatRenderReady=!1;let l=null;const c=(e,t)=>{this.isDisposingOrDisposed()||(!this.gpuAcceleratedSort&&this.sortWorker&&this.sortWorker.postMessage({centers:e.centers.buffer,sceneIndexes:e.sceneIndexes.buffer,range:{from:e.from,to:e.to,count:e.count}}),this.updateSplatSort(!0),o?this.splatRenderReady=!0:this.runAfterNextSort.push((()=>{this.splatRenderReady=!0})),this.runAfterNextSort.push((()=>{null!==l&&(this.loadingSpinner.removeTask(l),l=null),t()})))};return new Promise((o=>{n&&(l=this.loadingSpinner.addTask("Processing splats...")),d((()=>{if(this.isDisposingOrDisposed())o();else{const n=this.addSplatBuffersToMesh(e,t,s,r,i,a),l=this.splatMesh.getMaxSplatCount();this.sortWorker&&this.sortWorker.maxSplatCount!==l&&this.disposeSortWorker();(!this.sortWorker&&l>0?this.setupSortWorker(this.splatMesh):Promise.resolve()).then((()=>{c(n,o)}))}}),!0)}))}}();addSplatBuffersToMesh=function(){let e;return function(t,s,n=!0,r=!1,i=!1,o=!0){if(this.isDisposingOrDisposed())return;let a=[],l=[];i||(a=this.splatMesh.scenes.map((e=>e.splatBuffer))||[],l=this.splatMesh.sceneOptions?this.splatMesh.sceneOptions.map((e=>e)):[]),a.push(...t),l.push(...s),this.renderer&&this.splatMesh.setRenderer(this.renderer);const c=this.splatMesh.build(a,l,!0,n,(t=>{if(this.isDisposingOrDisposed())return;const s=this.splatMesh.getSplatCount();r&&s>=15e5&&(t||e||(this.loadingSpinner.setMinimized(!0,!0),e=this.loadingSpinner.addTask("Optimizing splats...")))}),(t=>{this.isDisposingOrDisposed()||t&&e&&(this.loadingSpinner.removeTask(e),e=null)}),o);return n&&this.freeIntermediateSplatData&&this.splatMesh.freeIntermediateSplatData(),c}}();setupSortWorker(e){if(!this.isDisposingOrDisposed())return new Promise((t=>{const s=this.integerBasedSort?Int32Array:Float32Array,n=e.getSplatCount(),r=e.getMaxSplatCount();this.sortWorker=function(e,t,s,n,r){const i=new Worker(URL.createObjectURL(new Blob(["(",zt.toString(),")(self)"],{type:"application/javascript"})));let o="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",a=g()?f():null;s||t?s?t||a&&a.major<16&&(o="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"):o=Qt:(o=Qt,a&&a.major<16&&(o="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"));const l=atob(o),c=new Uint8Array(l.length);for(let e=0;e<l.length;e++)c[e]=l.charCodeAt(e);return i.postMessage({init:{sorterWasmBytes:c.buffer,splatCount:e,useSharedMemory:t,integerBasedSort:n,dynamicMode:r,Constants:{BytesPerFloat:S.BytesPerFloat,BytesPerInt:S.BytesPerInt,DepthMapRange:S.DepthMapRange,MemoryPageSize:S.MemoryPageSize,MaxScenes:S.MaxScenes}}}),i}(r,this.sharedMemoryForWorkers,this.enableSIMDInSort,this.integerBasedSort,this.splatMesh.dynamicMode),this.sortWorker.onmessage=e=>{if(e.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,e.data.splatRenderCount);else{const t=new Uint32Array(e.data.sortedIndexes.buffer,0,e.data.splatRenderCount);this.splatMesh.updateRenderIndexes(t,e.data.splatRenderCount)}this.lastSortTime=e.data.sortTime,this.sortPromiseResolver(),this.sortPromiseResolver=null,this.forceRenderNextFrame(),this.runAfterNextSort.length>0&&(this.runAfterNextSort.forEach((e=>{e()})),this.runAfterNextSort.length=0)}else if(e.data.sortCanceled)this.sortRunning=!1;else if(e.data.sortSetupPhase1Complete){this.logLevel>=Lt.Info&&console.log("Sorting web worker WASM setup complete."),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(e.data.sortedIndexesBuffer,e.data.sortedIndexesOffset,r),this.sortWorkerIndexesToSort=new Uint32Array(e.data.indexesToSortBuffer,e.data.indexesToSortOffset,r),this.sortWorkerPrecomputedDistances=new s(e.data.precomputedDistancesBuffer,e.data.precomputedDistancesOffset,r),this.sortWorkerTransforms=new Float32Array(e.data.transformsBuffer,e.data.transformsOffset,16*S.MaxScenes)):(this.sortWorkerIndexesToSort=new Uint32Array(r),this.sortWorkerPrecomputedDistances=new s(r),this.sortWorkerTransforms=new Float32Array(16*S.MaxScenes));for(let e=0;e<n;e++)this.sortWorkerIndexesToSort[e]=e;if(this.sortWorker.maxSplatCount=r,this.logLevel>=Lt.Info){console.log("Sorting web worker ready.");const e=this.splatMesh.getSplatDataTextures(),t=e.covariances.size,s=e.centerColors.size;console.log("Covariances texture size: "+t.x+" x "+t.y),console.log("Centers/colors texture size: "+s.x+" x "+s.y)}t()}}}))}disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortPromise=null,this.sortPromiseResolver&&(this.sortPromiseResolver(),this.sortPromiseResolver=null),this.sortRunning=!1}removeSplatScene(e,t=!0){if(this.isLoadingOrUnloading())throw new Error("Cannot remove splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot remove splat scene after dispose() is called.");let s;return this.splatSceneRemovalPromise=new Promise(((n,r)=>{let i;t&&(this.loadingSpinner.removeAllTasks(),this.loadingSpinner.show(),i=this.loadingSpinner.addTask("Removing splat scene..."));const o=()=>{t&&(this.loadingSpinner.hide(),this.loadingSpinner.removeTask(i))},a=e=>{o(),this.splatSceneRemovalPromise=null,e?r(e):n()},l=()=>!!this.isDisposingOrDisposed()&&(a(),!0);s=this.sortPromise||Promise.resolve(),s.then((()=>{if(l())return;const t=[],n=[],r=[];for(let s=0;s<this.splatMesh.scenes.length;s++)if(s!==e){const e=this.splatMesh.scenes[s];t.push(e.splatBuffer),n.push(this.splatMesh.sceneOptions[s]),r.push({position:e.position.clone(),quaternion:e.quaternion.clone(),scale:e.scale.clone()})}this.disposeSortWorker(),this.splatMesh.dispose(),this.createSplatMesh(),this.addSplatBuffers(t,n,!0,!1,!0).then((()=>{l()||(o(),this.splatMesh.scenes.forEach(((e,t)=>{e.position.copy(r[t].position),e.quaternion.copy(r[t].quaternion),e.scale.copy(r[t].scale)})),this.splatMesh.updateTransforms(),this.splatRenderReady=!1,this.updateSplatSort(!0).then((()=>{l()?this.splatRenderReady=!0:(s=this.sortPromise||Promise.resolve(),s.then((()=>{this.splatRenderReady=!0,a()})))})))})).catch((e=>{a(e)}))}))})),this.splatSceneRemovalPromise}start(){if(!this.selfDrivenMode)throw new Error("Cannot start viewer unless it is in self driven mode.");this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode||cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){this.disposing=!0;let e=[],t=[];for(let s in this.splatSceneDownloadPromises)if(this.splatSceneDownloadPromises.hasOwnProperty(s)){const n=this.splatSceneDownloadPromises[s];t.push(n),e.push(n.promise)}this.sortPromise&&e.push(this.sortPromise);const s=Promise.all(e).finally((()=>{this.stop(),this.controls&&(this.controls.dispose(),this.controls=null),this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.disposeSortWorker(),this.removeEventHandlers(),this.loadingSpinner.removeAllTasks(),this.loadingSpinner.setContainer(null),this.loadingProgressBar.hide(),this.loadingProgressBar.setContainer(null),this.infoPanel.setContainer(null),this.camera=null,this.threeScene=null,this.splatRenderReady=!1,this.initialized=!1,this.renderer&&(this.usingExternalRenderer||(this.rootElement.removeChild(this.renderer.domElement),this.renderer.dispose()),this.renderer=null),this.usingExternalRenderer||document.body.removeChild(this.rootElement),this.sortWorkerSortedIndexes=null,this.sortWorkerIndexesToSort=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.disposed=!0,this.disposing=!1}));return t.forEach((e=>{e.abort("Scene disposed")})),s}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.shouldRender()?(this.render(),this.consecutiveRenderFrames++):this.consecutiveRenderFrames=0,this.renderNextFrame=!1}forceRenderNextFrame(){this.renderNextFrame=!0}shouldRender=function(){let e=0;const t=new n.Vector3,s=new n.Quaternion,r=1e-4;return function(){let n=!1,i=!1;if(this.camera){const e=this.camera.position,n=this.camera.quaternion;i=Math.abs(e.x-t.x)>r||Math.abs(e.y-t.y)>r||Math.abs(e.z-t.z)>r||Math.abs(n.x-s.x)>r||Math.abs(n.y-s.y)>r||Math.abs(n.z-s.z)>r||Math.abs(n.w-s.w)>r}return n=this.renderMode!==Kt.Never&&(0===e||this.splatMesh.visibleRegionChanging||i||this.renderMode===Kt.Always||!0===this.dynamicMode||this.renderNextFrame),this.camera&&(t.copy(this.camera.position),s.copy(this.camera.quaternion)),e++,n}}();render=function(){if(!this.initialized||!this.splatRenderReady)return;const e=this.renderer.autoClear;(e=>{for(let t of e.children)if(t.visible)return!0;return!1})(this.threeScene)&&(this.renderer.render(this.threeScene,this.camera),this.renderer.autoClear=!1),this.renderer.render(this.splatMesh,this.camera),this.renderer.autoClear=!1,this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=e};update(e,t){this.dropInMode&&this.updateForDropInMode(e,t),this.initialized&&this.splatRenderReady&&(this.controls&&(this.controls.update(),this.camera.isOrthographicCamera&&!this.usingExternalCamera&&jt.setCameraPositionFromZoom(this.camera,this.camera,this.controls)),this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),this.updateSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,t){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=t,this.controls&&(this.controls.object=t),this.init()}updateFPS=function(){let e=c(),t=0;return function(){if(this.consecutiveRenderFrames>60){const s=c();s-e>=1?(this.currentFPS=t,t=0,e=s):t++}else this.currentFPS=null}}();updateForRendererSizeChanges=function(){const e=new n.Vector2,t=new n.Vector2;let s;return function(){this.usingExternalCamera||(this.renderer.getSize(t),void 0!==s&&s===this.camera.isOrthographicCamera&&t.x===e.x&&t.y===e.y||(this.camera.isOrthographicCamera?(this.camera.left=-t.x/2,this.camera.right=t.x/2,this.camera.top=t.y/2,this.camera.bottom=-t.y/2):this.camera.aspect=t.x/t.y,this.camera.updateProjectionMatrix(),e.copy(t),s=this.camera.isOrthographicCamera))}}();timingSensitiveUpdates=function(){let e;return function(){const t=c();e||(e=t);const s=t-e;this.updateCameraTransition(t),this.updateFocusMarker(s),e=t}}();updateCameraTransition=function(){let e=new n.Vector3,t=new n.Vector3,s=new n.Vector3;return function(n){if(this.transitioningCameraTarget){t.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),s.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const r=Math.acos(t.dot(s)),i=(r/(Math.PI/3)*.65+.3)/r*(n-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,i),this.camera.lookAt(e),this.controls.target.copy(e),i>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const e=new n.Vector2;let t=!1;return function(s){if(this.getRenderDimensions(e),this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const n=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let r=Math.min(n+10*s,1);this.sceneHelper.setFocusMarkerOpacity(r),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),t=!0,this.forceRenderNextFrame()}else{let n;if(n=t?1:Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),n>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let t=Math.max(n-2.5*s,0);this.sceneHelper.setFocusMarkerOpacity(t),0===t&&this.sceneHelper.setFocusMarkerVisibility(!1)}n>0&&this.forceRenderNextFrame(),t=!1}}}();updateMeshCursor=function(){const e=[],t=new n.Vector2;return function(){this.showMeshCursor?(this.forceRenderNextFrame(),this.getRenderDimensions(t),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,t),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):(this.sceneHelper.getMeschCursorVisibility()&&this.forceRenderNextFrame(),this.sceneHelper.setMeshCursorVisibility(!1))}}();updateInfoPanel=function(){const e=new n.Vector2;return function(){if(!this.showInfo)return;const t=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const s=this.controls?this.controls.target:null,n=this.showMeshCursor?this.sceneHelper.meshCursor.position:null,r=t>0?this.splatRenderCount/t*100:0;this.infoPanel.update(e,this.camera.position,s,this.camera.up,this.camera.isOrthographicCamera,n,this.currentFPS||"N/A",t,this.splatRenderCount,r,this.lastSortTime,this.focalAdjustment,this.splatMesh.getSplatScale(),this.splatMesh.getPointCloudModeEnabled())}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}updateSplatSort=function(){const e=new n.Matrix4,t=[],s=new n.Vector3(0,0,-1),r=new n.Vector3(0,0,-1),i=new n.Vector3,o=new n.Vector3,a=[],l=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return async function(n=!1){if(this.sortRunning)return;if(this.splatMesh.getSplatCount()<=0)return;let c=0,h=0,d=!1,p=!1;if(r.set(0,0,-1).applyQuaternion(this.camera.quaternion),c=r.dot(s),h=o.copy(this.camera.position).sub(i).length(),!(n||this.splatMesh.dynamicMode||0!==a.length||(c<=.99&&(d=!0),h>=1&&(p=!0),d||p)))return;this.sortRunning=!0;const{splatRenderCount:u,shouldSortAll:A}=this.gatherSceneNodesForSort();this.splatRenderCount=u,e.copy(this.camera.matrixWorld).invert();const m=this.perspectiveCamera||this.camera;if(e.premultiply(m.projectionMatrix),e.multiply(this.splatMesh.matrixWorld),this.gpuAcceleratedSort&&(a.length<=1||a.length%2==0)&&await this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances),this.splatMesh.dynamicMode||A)a.push(this.splatRenderCount);else if(0===a.length){for(let e of l)if(c<e.angleThreshold){for(let t of e.sortFractions)a.push(Math.floor(this.splatRenderCount*t));break}a.push(this.splatRenderCount)}let g=Math.min(a.shift(),this.splatRenderCount);t[0]=this.camera.position.x,t[1]=this.camera.position.y,t[2]=this.camera.position.z;const f={modelViewProj:e.elements,cameraPosition:t,splatRenderCount:this.splatRenderCount,splatSortCount:g,usePrecomputedDistances:this.gpuAcceleratedSort};this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(f.indexesToSort=this.sortWorkerIndexesToSort,f.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(f.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortPromise=new Promise((e=>{this.sortPromiseResolver=e})),this.sortWorker.postMessage({sort:f}),0===a.length&&(i.copy(this.camera.position),s.copy(r))}}();gatherSceneNodesForSort=function(){const e=[];let t=null;const s=new n.Vector3,r=new n.Vector3,i=new n.Vector3,o=new n.Matrix4,a=new n.Matrix4,l=new n.Matrix4,c=new n.Vector3,h=new n.Vector3(0,0,-1),d=new n.Vector3,p=e=>d.copy(e.max).sub(e.min).length();return function(d=!1){this.getRenderDimensions(c);const u=c.y/2/Math.tan(this.camera.fov/2*n.MathUtils.DEG2RAD),A=Math.atan(c.x/2/u),m=Math.atan(c.y/2/u),g=Math.cos(A),f=Math.cos(m),C=this.splatMesh.getSplatTree();if(C){a.copy(this.camera.matrixWorld).invert(),a.multiply(this.splatMesh.matrixWorld);let t=0,n=0;for(let c=0;c<C.subTrees.length;c++){const u=C.subTrees[c];o.copy(a),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(c,l),o.multiply(l));const A=u.nodesWithIndexes.length;for(let a=0;a<A;a++){const l=u.nodesWithIndexes[a];if(!l.data||!l.data.indexes||0===l.data.indexes.length)continue;i.copy(l.center).applyMatrix4(o);const c=i.length();i.normalize(),s.copy(i).setX(0).normalize(),r.copy(i).setY(0).normalize();const A=h.dot(r),m=h.dot(s),C=p(l);!d&&(A<g-.6||m<f-.6)&&c>C||(n+=l.data.indexes.length,e[t]=l,l.data.distanceToNode=c,t++)}}e.length=t,e.sort(((e,t)=>e.data.distanceToNode<t.data.distanceToNode?-1:1));let c=n*S.BytesPerInt;for(let s=0;s<t;s++){const t=e[s],n=t.data.indexes.length,r=n*S.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,c-r,n).set(t.data.indexes),c-=r}return{splatRenderCount:n,shouldSortAll:!1}}{const e=this.splatMesh.getSplatCount();if(!t||t.length!==e){t=new Uint32Array(e);for(let s=0;s<e;s++)t[s]=s}return this.sortWorkerIndexesToSort.set(t),{splatRenderCount:e,shouldSortAll:!0}}}}();getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}isMobile(){return navigator.userAgent.includes("Mobi")}}class Wt extends n.Group{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.ignoreDevicePixelRatio=!1,e.dropInMode=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new jt(e),this.splatMesh=null,this.callbackMesh=Wt.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=Wt.onBeforeRender.bind(this,this.viewer)}addSplatScene(e,t={}){return!1!==t.showLoadingUI&&(t.showLoadingUI=!0),this.viewer.addSplatScene(e,t)}addSplatScenes(e,t){return!1!==t&&(t=!0),this.viewer.addSplatScenes(e,t)}getSplatScene(e){return this.viewer.getSplatScene(e)}removeSplatScene(e){return this.viewer.removeSplatScene(e)}dispose(){return this.viewer.dispose()}static onBeforeRender(e,t,s,n){this.splatMesh!==this.viewer.splatMesh&&(this.splatMesh&&this.remove(this.splatMesh),this.splatMesh=this.viewer.splatMesh,this.add(this.viewer.splatMesh)),e.update(t,n)}static createCallbackMesh(){const e=new n.SphereGeometry(1,8,8),t=new n.MeshBasicMaterial;t.colorWrite=!1,t.depthWrite=!1;const s=new n.Mesh(e,t);return s.frustumCulled=!1,s}}e.AbortablePromise=r,e.DropInViewer=Wt,e.KSplatLoader=rt,e.LoaderUtils=at,e.LogLevel=Lt,e.OrbitControls=At,e.PlayCanvasCompressedPlyParser=O,e.PlyLoader=tt,e.PlyParser=qe,e.RenderMode=Kt,e.SceneFormat=it,e.SceneRevealMode=Ht,e.SplatBuffer=D,e.SplatBufferGenerator=Xe,e.SplatLoader=nt,e.SplatParser=st,e.SplatPartitioner=Ye,e.Viewer=jt,e.WebXRMode=Vt}));
//# sourceMappingURL=gaussian-splats-3d.umd.min.cjs.map
